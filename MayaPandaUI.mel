///////////////////////////////////////////////////////////////////////////////////
// Panda3D Exporter Tool                                                         //
// Carnegie Mellon University ETC (Entertainment Technology Center) Panda3D Team //
// Author: Shao Zhang                                                            //
// 04/14/2005                                                                    //
//                                                                               //
// This tool will allow an artist to export and view assets directly from maya.  //
//                                                                               //
// To run this mel script, drag and drop it (the .mel file) into your current    //
// maya workspace.                                                               //
///////////////////////////////////////////////////////////////////////////////////
//
// EDIT HISTORY
//
// 06/26/06: ynjh_jo - Major edits; described in http://panda3d.net/phpbb2/viewtopic.php?t=2503
// 07/03/06: Mark Tomczak (fixermark@gmail.com) - Added "Actor" option to export with -a model option
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// maya panda exporter GUI
//
// 10/1/2011 : updated custom filepath buttons to use new fileDialog2 command
//
// rewrite by ben chang, 9/16/09
//
// - redid layout for linux
// - added menu command with handy tools
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// - 2/17/2014 : Mods by Sean / a.k.a "Sweet"
// - Rewrote some of the script for menu layout
// - --(this was done as it wouldn't fit on my monitor resolution of 1360 x 768)
// - Edited some of the code so that the egg/bam output would actually create a "bam file"
// - On exporting a Bam, the script still lacks in this feature somewhat,
// - --in that it will not let you pick a previous egg file and create a Bam.
// - Also, you have to choose BOTH on export if you want Maya to create a egg & bam file set
// -
// - 2/25/2014 : Mods by Sean / a.k.a "Sweet"
// - Modified GUI layout to clear some un needed free spacing
// - Fixed the Bam file exporting
// -
// - 6/12/2014 : Mods by Sean / a.k.a "Sweet"
// - Modified GUI layout to accomodate changes
// - Added buttons & functions for "Maya File 2 Egg", "Egg File 2 Bam", "Egg Preview"
// - Added checkbox and function for "-rawtex" Bam file output option
// -
// - 6/13/2014 : Mods by Sean / a.k.a "Sweet"
// - Added Title separator for the "-rawtex" Bam Specific Options
// -
// - 06/14/2014 : Mods by Sean / a.k.a "Sweet"
// - Added button and Functions for "Bam2Egg" conversion
// -
// - 06/09/2015 : Mods by Sean / a.k.a "Sweet"
// - Cleaned up some of the coding to be more efficient.
// - Adjusted frameLayout calls to be Maya MEL 2016 compliant. (still funtions with Maya 2015 MEL).
// - They depreciated the '-borderStyle(-bs)' command in Maya 2016.
// - Added text boxes and commands for [-cn <name>] , maya2egg* command, for adding a Character Name
// - --to exported file.
// - Added text boxes and commands for utilizing the [-force-joint <name>] , maya2egg* command.
// - Added an automatic single -v for diplaying some verbosity in script editor when exporting.
// - Added more [-trans type] options, to cover all maya2egg* options available.
// - --The option may be one of all, model, dcs, or none.
// - Rewrote exporting code some to enable the ability to export, using custom name and directory without
// - --needing to save the scene first.
// - It will export the temp file using the chosen custom name, in the custom directory first, then convert that // - file.
// - It will now always export the temp file into a chosen custom directory path, if one is chosen.
// - Added Bam Specific Option [-flatten flag] to choices.
// -
// - 07/06/2015 : Mods by Sean / a.k.a "Sweet"
// - Corrected bad entry to the pview program call. I had pview_638 and should be just pview.
// -
// - 09/15/2015 : Mods by Sean / a.k.a "Sweet"
// - Rewrote the addCollisionFlags process. It now takes a string variable.
// - Added 'Convert Lights' to Export Options.
// - ----NOTE: Will Convert any lights to locators in the egg/bam file.
// - --Lights will only export in a static mesh model, Not in actor/animation files.
// - Rewrote the force-joint process in the ARGS process.
// - --It now can process multiple enitries, space separated, in the Force Joint text box.
// - --It also checks the entered node names to verify that they have the DCS egg-type flag.
// - --If it detects one or more do not, it will add the DCS flag to them and restart the export process.
// - Changed naming conventions for the egg2bam & bam2egg variables.
// - Corrected diplayed revision number.
// - Updated all fileDialog calls to fileDialog2.
// -
// - 10/08/2015 : Mods by Sean / a.k.a "Sweet"
// - Added code to Panda File importing to prevent selected Bam files from being deleted
// - --if the file originates from the Phase Root Folder.
// -
// - 03/08/2016 : Mods by Sean /a.k.a. "Sweet"
// - Changed name of 'addCollisionFlags' process to more appropriate 'MP_AddEggObjectFlags'.
// - Completely rewrote 'MP_AddEggObjectFlags' process for both optimization and for backward compatibility with // - Maya2012.
// - For Maya2012 compatible:
// - --Maya2012 did not support my previous update utilizing the 'stringArrayFind' command.
// - Added a sub-process MP_SetEggObjectTypeAttribute which gets passed numerous variables.
// - --The main process verifies the tag is not already assigned to the node eliminating possible duplicates.
// - --If tag is already present, user gets prompted of such.
// - --The global array that holds the egg-object-type tags is user editable so updates can be made to it.
// - --The main process 'MP_AddEggObjectFlags' gets passed a string variable which is the tag to be added
// - --This now makes it possible to add tags via scripts by simply passing the tag to the process.
// - Rewrote 'Bam2EggVersion' & 'Egg2BamVersion' code and combined the two processes
// - --into one, which is now just called BamFileVersions. The purpose for modifying these into one,
// - --was for streamlining code and for the ability to now handle multiple Panda3D bam file version of the
// - --executables.
// - The user can modify the array '$gMP_PandaFileVersions' that holds the executable names for the ability to
// - --export scenes to the initial egg file then have it compile using different Bam versions.
// - ----(Provided others are installed).
// - --This also allows for multiple pview and egg2bam versions to be utilized through the GUI.
// - ----(Read more about this in the MP_Globals process section)
// - Added a global process 'MP_Globals' to hold the global variables used in script.
// - Added a sub process for handling animation start & end frames
// - --Now, when an animation layer is selected, (highlighted in Maya)
// - --and the user selects to export a type supportive of animations
// - --the script determines the last key frame in the animation layer and uses that number to adjust
// - --the endFrame text on the GUI and also updates the Time Slider
// - --and Range Sliders based on the frames it found.
// - --Since it is based on key frames, if the last key frame is not the last frame,
// - --as before, the user will have to manually adjust the setting prior to exporting.
// - Rewrote most of the code related to the 'pview' operations.
// - --Prior to this release, the code relied completely on calling
// - ----the system command process which ran the pview command.
// - --Now, with a little better understanding of the pview plugins, the code
// - ----utilizes them when the user has selected to run pview after exporting.
// - --Primarily, when the mayapview[version].mll is loaded.
// - --When this one plugin is loaded, it calls pview from within the Maya program after exporting,
// - ----substantially speeding up the process.
// - --Conversly, if the 'mayasavepview[version].mll is the loaded plugin, or if neither plugin is loaded,
// - ----we still rely on the system being queried to run pview.exe
// - Added the 'Import Panda File' button and process.
// - --When this button is clicked, if it is the first time in the session,
// - ----it first asks the user to choose the parent directory
// - ----that has all the extracted phase_* folders in it. i.e., the phase root folder.
// - --After this has been chosen, the user then chooses either a Panda Egg or Panda Bam file.
// - --Once one of those have been selected, if it was a bam file, it first converts it to an egg file,
// - ----then it imports the file into the current scene.
// - --If it is an egg file, it simply imports it to the current scene.
// - --The process asks for the [Phase Root Folder], simply because, based on Disney's file structure,
// - ----the bam file textures are reletive to this root folder.
// - --The process creates a temporary copy of the bam file in this root directory,
// - ----and runs egg2bam on it there.
// - --After the converted egg file has been imported, it removes the copied bam file but leaves the egg file.
// - --Added a routine to check if Panda Egg Import Plugin is currently loaded in Maya
// - ----when importing a Panda file.
// - --Since this is necesary for importing eggs, if it is not loaded, we prompt the user they are NOT loaded
// - ----and directs them to download Panda3D-SDK.
// - Added the 'Convert Nodes To Panda' button and process.
// - Added a child window for adding egg-object-type tags. This should make adding the tags a lot simpler
// - --as they can now be directly added instead of adding a basic tag, then editing it to the type needed.
// - --It auto-creates the buttons based on teh global array entries that can be user edited as needed.
// - Added an over-looked missing file from previous releases, 'eggImportOptions.mel'
// - --This file creates/displays the import options when the file>import GUI screen is called.
// -
// - 03/20/2016 : Mods by Sean /a.k.a. "Sweet"
// - Added Export Option 'Convert Cameras' which will Convert all camera nodes to locators.
// - --There position and rotation will be preserved.
// - Added Texture Reference Path option to 'Output Path & Name Options'.
// - --It's now posssible to reference textures to a specified path without it also copying the
// - ----textures to that directory.
// - --The option to copy textures and reference them to a custom file output path exists as an option as well.
// - --This feature works when clicking 'Maya File 2 Egg' or 'Egg File 2 Bam' as well.
// - Modified 'MP_ArgsBuilder' and 'MP_Export2Bam' process to support updated relative texture pathing options.
// - Modified 'MP_BrowseForFolderPreProcess' processing code to allow for updated
// - --relative texture pathing options above
// - --Cleaned out some unused switch options in process.
// - Miscellaneous code cleanups.
// - Modified, cleaned and streamlined 'MP_ExportPrep' and 'MP_Export2Bam' processes for complex functions
// - --that were no longer needed due to previous revisions.
// - Reworked the 'pview' related codes.
// - --Now, if exporting scene or node(s) to panda files, system command pview is run against final exported file.
// - --If not exporting, then it sends either the selected or entire scene to the 'libmayapview' plugin if loaded.
// - The use of 'libmayasavepview' has been completely eliminated as it's simply not needed.
// -
// - 06/08/2016 : Mods by Sean /a.k.a. "Sweet"
// - Modified main GUI layout to add section for Egg-Object-Tag buttons.
// - Added new method and functions for easily deleting current egg-object-type tags that nodes contain.
// -
// - 06/22/2016 : Mods by Sean /a.k.a. "Sweet"
// - Recode GUI to accomodate the 'Bam file Texture Ref Path'
// - Added 'MP_OutputPandaFileTypeUI' process for new text box and corrected options
// - Adjusted coding of the 'MP_TexPathOptionsUI' process for new text box and corrected options
// - Modified code in 'MP_ArgsBuilder' and 'MP_Export2Bam' process to add to and correct for errors
// - --from a previous update involving texture referencing:
// - 
// - When using 'Reference textures relative to specified path':
// - If exporting to ONLY an egg file:
// - --The egg file textures will be referenced to the specified path.
// - --NOTE: The reference path MUST start with the path to the Maya file being utilized
// - If exporting to both an egg file and a bam file, the bam file is now properly generated.
// - --The egg file textures WILL be referenced relative to the Maya file.
// - --The bam file textures will be referenced to the specified path.
// - --NOTE: The reference path MUST start with the path to the Maya file being utilized
// - If calling an egg file to bam up, the referencing and/or copying options will also
// - --function as they should. Referencing options in this case change based on the
// - --setting of 'Output File Type' prior to browsing for egg file.
// - 
// - When using 'Copy textures and make relative to specified path':
// - If exporting to ONLY an egg file:
// - --The textures will be copied-to the specified path.
// - --The egg file textures will be referenced to the copied-to path.
// - If exporting to both an egg file and a bam file, the bam file is now properly generated.
// - --The textures will be copied-to the specified path.
// - --The egg file textures WILL be referenced relative to the Maya file.
// - --The bam file textures will be referenced to the copied-to path.
// - If calling an egg file to bam up:
// - --The referencing and/or copying options also function as they do above.
// - --Referencing options in this case, however, change based on the setting of 'Output File Type'
// - ----prior to browsing for egg file.
// - --If the egg only option is enabled:
// - ----The original textures will be copied-to the specified path.
// - ----The bam file textures will be made relative to this path.
// - --If the egg and bam file option is enabled:
// - ----The original textures will be copied-to the specified path in the 'Egg file Texture Ref Path' text box.
// - ----The bam file textures will be relative to the path specified in the 'Bam file Texture Ref Path' text box.
// - ----NOTE: The reference path MUST start with the path to the copied-to path being utilized.
// - 
// - 07/11/2017 : Mods by Sean /a.k.a. "Sweet" (primary coding was done 07/06/2016)
// - Added support to the following processes to handle converting multiple files at one time.
// - --MP_BrowseForFile, MP_GetEggFile2Bam, MP_GetMayaFile2Egg, MP_GetBamFile2Egg, MP_ImportPandaFile
// - By adding multiple file support,
// - --The script can now process more than one file at a time when performing these tasks.
// - Example: User wants to convert multiple files from eggs to bams.
// - --After clicking on the appropriate button to start processing, user can use standard windows function of
// - ----holding down the shift or control keys and click on the file(s) to select for conversion.
// - --The script will then process all the selected file(s) one at a time.
// - !!!!!!!!!!!!WARNING WHEN USING MULTIPLE FILE CONVERSIONS:!!!!!!!!!!!!
// - When attempting to convert multiple files, DO NOT USE THE CUSTOM NAME FEATURE. Doing so
// - --gives EVERY FILE the same export name. This will result in only the last file being created,
// - --as all previous files will have been over-writen by the previous file as they are created.
// - Added "MP_" suffix every process and many variables so the script cannot interfere with other scripts.
// - Added GUI checkBox and needed function(s) to remove the "groundPlane_transform" tuple from exported egg MESH files.
// - --While this Maya node is normally empty, care should be taken to ensure it is empty when exporting.
// - --Otherwise there runs the risk of data loss in the egg/bam file(s).
// - 
// - 10/01/2017 : Mods by Sean /a.k.a. "Sweet"
// - Added the ability to add UVScroll values to nodes via the "Add Egg Tags" GUI.
// - Recoded the way confirmDialogs pull their menu and annotation values.
// - Added egg-object-type button annotation.
// ---Now, descriptions pop up, when the mouse is hovered over the button(s), that describe what each button is for.
// - --This annotation was primarily taken right from the Panda3d information.
// - Added release notes from original developer that were missing from the version I initialy used to rewrite this script.
// ---Why 'Ben Chang' left these out from his version, I have no idea.
// ---But, I added them so the original developers would get their credit.
// -
// - 1/14/2020 : Mods by Benjamin Frisby
// - Added the "shadow-cast" egg-type-attribute to the "Add Egg Tags" GUI.
// - Added the "smooth-floors" egg-type-attribute to the "Add Egg Tags" GUI.
// -
/////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
// Process: MP_PandaVersion                              //
///////////////////////////////////////////////////////////
global proc string MP_PandaVersion(string $option)
{
    global string $gMP_PandaFileVersions[];
    string $executableToUse = "";
    string $selectedBamVersion = `optionMenu -query -value MP_BamVersionOptionMenu`;
    
        //Scan each loop for the value of the selected bam file version
        //bam2egg executable file name should be the next value (+1) after version in the array
        //egg2bam executable should be the second value (+2) after version in the array
        //pview executable should be the third value (+3) after version in the array
        //    EXAMPLE $gMP_PandaFileVersions ARRAY ENTRY: "Default","bam2egg","egg2bam","pview"
    for($i=0;$i<size($gMP_PandaFileVersions);$i++){
        if($selectedBamVersion == $gMP_PandaFileVersions[$i]){
            switch($option){
                case "getBam2Egg":
                            //Get bam2egg file name
                        $executableToUse = $gMP_PandaFileVersions[$i+1];
                break;
                case "getEgg2Bam":
                            //Get egg2bam file name
                        $executableToUse = $gMP_PandaFileVersions[$i+2];
                break;
                case "getPview":
                            //Get pview file name
                        $executableToUse = $gMP_PandaFileVersions[$i+3];
                break;
            }
            $i = size($gMP_PandaFileVersions);
        }
    }
    return $executableToUse;
}
/* Shows a confirmation dialog with specified buttons to the user and returns depressed button value.
    //
*/
///////////////////////////////////////////////////////////////
// Process: MP_ConfirmationDialog                            //
// Shows user a confirmation dialog UI                       //
///////////////////////////////////////////////////////////////
global proc string MP_ConfirmationDialog(string $title, string $message, string $type)
{
    /*
        Shows a confirmation dialog with the passed title and message
        to the user.
        The return value will be the value of the button that was pressed by user.
    */
    
    string $confirmValue = "";
    
    switch($type)
    {
        case "ok":
                //Displays only an 'OK' button to user
            $confirmValue = `confirmDialog -title $title
                                            -message $message
                                            -button "OK"
                                            -defaultButton "OK"
                                            -cancelButton "CANCEL"
                                            -dismissString "CANCEL"`;
        break;
        
        case "okcancel":
                //Displays an 'OK' and 'CANCEL' button to user
            $confirmValue = `confirmDialog -title $title
                                            -message $message
                                            -button "OK"
                                            -button "CANCEL"
                                            -defaultButton "OK"
                                            -cancelButton "CANCEL"
                                            -dismissString "CANCEL"`;
        break;
        
        case "selectcancel":
                //Displays an 'SELECT' and 'CANCEL' button to user
            $confirmValue = `confirmDialog -title $title
                                            -message $message
                                            -button "SELECT"
                                            -button "CANCEL"
                                            -defaultButton "SELECT"
                                            -cancelButton "CANCEL"
                                            -dismissString "CANCEL"`;
        break;
        
        case "yesno":
                //Displays a 'YES' and 'NO' button to user
            $confirmValue = `confirmDialog -title $title
                                            -message $message
                                            -button "YES"
                                            -button "NO"
                                            -defaultButton "YES"
                                            -cancelButton "NO"
                                            -dismissString "NO"`;
        break;
        
        case "downloadcancel":
                //Displays a 'Download' and 'Cancel' button to user
            $confirmValue = `confirmDialog -title $title
                                            -message $message
                                            -button "DOWNLOAD"
                                            -button "CANCEL"
                                            -defaultButton "DOWNLOAD"
                                            -cancelButton "CANCEL"
                                            -dismissString "CANCEL"`;
        break;
    }
        
        //Return the value
    return $confirmValue;
}
///////////////////////////////////////////////////////////
// Process: MP_AddEggObjectFlags                         //
// Add an egg-object-type to poly                        //
///////////////////////////////////////////////////////////
global proc MP_AddEggObjectFlags(string $eggObjectType)
{
        //global egg-object-type array
    global string $gMP_EggObjectTypeArray[];
    
        //generate attribute enumeration list from the array
    string $enumerationList = stringArrayToString($gMP_EggObjectTypeArray, ":");

        //Verify the eggObjectType that was passed to this process exists in the $gMP_EggObjectTypeArray array
        //If it does not, we skip processing and warn user.
    int $eggTypeInArray = stringArrayContains($eggObjectType, $gMP_EggObjectTypeArray);
    if($eggTypeInArray == 1){
            //String version of array index number.
            //This is necessary so we can verify the index number is not null/empty
        int $indexNumber = -1;
        
            //Get the array index number of the $eggObjectType passed to this process
            //by iterating through each array item and compare them to the $eggObjectType
        for($n=0;$n<size($gMP_EggObjectTypeArray);$n++){
            if($gMP_EggObjectTypeArray[$n] == $eggObjectType){
                $indexNumber = $n;
            }
        }
        
            //Varible to hold all currently selected nodes
        string $selectedNodes[] =`ls -sl`;
        
            //Iterate through each selected node one-by-one
        if( size($selectedNodes) == 0)
        {
            MP_ConfirmationDialog("Selection Error!", "You must first make a selection!"
                                                    + "\nPlease select at least one node, then try again.", "ok");
        }else{
            for ($node in $selectedNodes){
                for($i=1;$i<4;$i++){
                    if(`objExists ($node + ".eggObjectTypes" + $i)` == 1){
                            //Notify user if the lmit of 3 tags are already assigned to node
                        if($i == 3){
                                //Message to user that the egg-object-type limit has been reached
                            MP_ConfirmationDialog("Egg-Object-Type Error!", "Limit of 3 egg-object-types has already been reached."
                                                                            + "\nNo More Egg Object Types Supported for this node.", "ok");
                        }
                    }else{
                            //Call subprocess to check/set attribute
                        MP_SetEggObjectTypeAttribute($enumerationList, $eggObjectType, $indexNumber, $i, $node);
                            //Set variable to exit loop
                        $i = 4;
                    }
                }
            }
        }
    }else{
            //Message to user that the passed egg-object-type is NOT in the $gMP_EggObjectTypeArray array
        MP_ConfirmationDialog("Egg-Object-Type Error!", "The selected egg-object-type was not found in the $gMP_EggObjectTypeArray"
                                                    + "\n"
                                                    + "\nPlease verify the object-type being passed and update the $gMP_EggObjectTypeArray"
                                                    + "\nto include the egg-object-type if the type is the correct one needed."
                                                    + "\n"
                                                    + "\nIf you modify the $gMP_EggObjectTypeArray DO NOT forget to update your PRC files."
                                                    + "\nto include a reference of the egg-object-type you are adding.", "ok");
    }
    
        //Method to update the MP_DeleteEggObjectTypesWindow window if it is currently being shown
    if (`window -exists MP_DeleteEggObjectTypesWindow`){
        MP_GetEggObjectTypes();
    }
}
///////////////////////////////////////////////////////////
// Process: MP_SetEggObjectTypeAttribute                 //
// sub-process of MP_AddEggObjectFlags process           //
//      for setting egg-object-type attributes           //
///////////////////////////////////////////////////////////
global proc MP_SetEggObjectTypeAttribute(string $enumerationList, string $eggObjectType, int $indexNumber, int $attributeNumber, string $node)
{
        //Determining variable on whether we can add egg-object-type attribute to node
    int $addeggObjectTypeAttribute = 0;
    
        //Check for any currently attached egg-object-type attribute values on the node.
        //If a current attribute matches passed egg-object-type,
        //  we skip adding it again and notify user it already exists.
    for($i=1;$i<4;$i++){
        if(`objExists ($node + ".eggObjectTypes" + $i)`){
                //Attribute exists, check if attributes matches the passed egg-object-type
            if(`getAttr -asString ($node + ".eggObjectTypes" + $i)` == $eggObjectType){
                    //Message to user that the egg-object-type is already assigned to node
                MP_ConfirmationDialog("Egg-Object-Type Error!", "egg-object-type  -  \""
                                                                + $eggObjectType
                                                                + "\""
                                                                + "\n"
                                                                + "\nAlready attached on node attribute:  "
                                                                + "\n"
                                                                + ($node + ".eggObjectTypes" + $i), "ok");
                    
                    //Since attribute already exists on node, set our determining variable to 0 to skip adding it again
                $addeggObjectTypeAttribute = 1;
            }
        }
    }    
        
        //Adds the egg-object-type attribute to node if it was not already attached
    if($addeggObjectTypeAttribute == 0){
        addAttr -ln ("eggObjectTypes" + $attributeNumber) -keyable 1 -attributeType "enum" -enumName ($enumerationList) $node;
        setAttr ($node + ".eggObjectTypes" + $attributeNumber) $indexNumber;
    }
}
///////////////////////////////////////////////////////////
// Process: MP_AddEggObjectTypesGUI                      //
// Displays the GUI window for adding egg-object tags    //
///////////////////////////////////////////////////////////
global proc MP_AddEggObjectTypesGUI()
{
    /*
        Constructs and displays a GUI for adding egg-object-type tags to nodes.
        It is designed to read the contents in teh global $eggObjectTypeArray and 
        automatically create rows of 5 buttons each row in a separate window.
        The array can be modified in the MP_Globals process to the users liking.
        User must verify that any object types added to the array are also present
        in at least one of their PRC files, otherwise egg2bam will error complaining
        about an unknown object-type.
    */
    
    global string $gMP_EggObjectTypeArray[];
    
        //Delete any current instances of the MP_AddEggObjectTypesWindow window
    if (`window -exists MP_AddEggObjectTypesWindow`){
        deleteUI -window MP_AddEggObjectTypesWindow;
    }
    
    window -retain -title "Panda Exporter - Add Egg-Object-Types" -resizeToFitChildren true -sizeable 0 -visible 1 MP_AddEggObjectTypesWindow;
        columnLayout -columnAttach "left" 0 -adjustableColumn true -rowSpacing 0;
            frameLayout -backgroundColor 0.50 0.60 0.20    //Add Egg-Type Tags
                        -collapsable false -font "obliqueLabelFont" -label "Add Egg-Object-Type Tags to Selected Nodes";
                columnLayout -adjustableColumn true;
                    int $count = 0;
                    for($n=0;$n<(size($gMP_EggObjectTypeArray)+1)/4;$n++){
                        rowLayout -nc 6;
                            for($i=0;$i<5;$i++){
                                
                                string $eggObjectType = $gMP_EggObjectTypeArray[$count];
                                
                                if($eggObjectType != ""){
                                        
                                        //Get the defined annotation for egg-object-type
                                        string $annotation = MP_GetObjectTypeAnnotation($eggObjectType);
                                        
                                        button -label $eggObjectType
                                            -width 100 -height 17
                                            -annotation $annotation
                                            -command ("MP_AddEggObjectFlags\"" + $eggObjectType + "\"");
                                    $count++;
                                }
                            }
                        setParent -u;
                    }
                    separator -height 5 -style "none";
                    rowLayout -nc 1 -columnAttach 1 "left" 100;
                        text -bgc 0.350 0.820 0.950 -label ("Object types added to nodes can be edited by selecting the node"
                                        + "\n and viewing the attributes in the channels box of the node.");
                    setParent -u;
                setParent -u;
            setParent -u;
            
            int $UVScrollFrameHeight = 125;
            frameLayout -backgroundColor 0.50 0.60 0.20 -height $UVScrollFrameHeight
                        -collapsable false -font "obliqueLabelFont" -label "Set Texture UV Scrolling";
                columnLayout -columnAttach "left" 15 -rowSpacing 0;    //----- UV Scrolling
                    rowLayout -nc 1;    //----- UV Scrolling set speed Comment
                        text -label "Can use [float] or -[float] to set speed and direction of scrolling" -font "smallBoldLabelFont";
                    setParent -u;
                    rowLayout -nc 6;    //----- UV Scrolling Labels
                        text -label "scroll 'U(X)'" -font "smallBoldLabelFont";
                        separator -width 5 -style "none";
                        text -label "scroll 'V(Y)'" -font "smallBoldLabelFont";
                        separator -width 5 -style "none";
                        text -label "scroll 'R(Z)'" -font "smallBoldLabelFont";
                    setParent -u;
                    rowLayout -nc 6;    //----- UV Scrolling TextFields
                        floatField -width 40 -precision 3 -nbg false -enable 1 -value 0 scrollUFF;
                        separator -width 12 -style "none";
                        floatField -width 40 -precision 3 -nbg false -enable 1 -value 0 scrollVFF;
                        separator -width 12 -style "none";
                        floatField -width 40 -precision 3 -nbg false -enable 1 -value 0 scrollRFF;
                    setParent -u;
                    rowLayout -nc 8;    //----- UV Scrolling Buttons
                        button -label "Set/Update"
                                -width 80
                                -height 17
                                -annotation "Set or Update the scroll values of selected node."
                                -command ("MP_UVScrolling \"set\"")
                                SetCurrentUVScroll;
                        button -label "Get Current"
                                -width 80
                                -height 17
                                -annotation "Get the current UVScroll values of the selected node."
                                -command ("MP_UVScrolling \"get\"")
                                GetCurrentUVScroll;
                        button -label "Delete"
                                -width 80
                                -height 17
                                -annotation "Remove the scroll values of selected node."
                                -command ("MP_UVScrolling \"delete\"")
                                deleteCurrentUVScroll;
                    setParent -u;
                setParent -u;
            setParent -u;
        setParent -u;
    showWindow MP_AddEggObjectTypesWindow;
        //Set window height: base height 10 + 19 per button row
    int $buttonFrameHeight = ((($n+1) * 19) + 10);
    window -edit -width 515 -height ($buttonFrameHeight + $UVScrollFrameHeight) MP_AddEggObjectTypesWindow;
}
///////////////////////////////////////////////////////////
//  Process:  MP_UVScrolling                             //
//  Process to set/edit the UV scrolling of a texture.   //
///////////////////////////////////////////////////////////
global proc MP_UVScrolling(string $Option)
{
    string $item, $buff[] ;
    int $numTokens ;
    float $scrollU, $scrollV, $scrollR;
    
    
    if (`floatField -query -value scrollUFF` == 0)
    {
        $scrollU = 0;
    }
    else
    {
        $scrollU = `floatField -query -value scrollUFF`;
    }
    if (`floatField -query -value scrollVFF` == "")
    {
        $scrollV = 0;
    }
    else
    {
        $scrollV = `floatField -query -value scrollVFF`;
    }
    if (`floatField -query -value scrollRFF` == "")
    {
        $scrollR = 0;
    }
    else
    {
        $scrollR = `floatField -query -value scrollRFF`;
    }
    
    string $nodeName[] =`ls -l -sl`;
    if( size($nodeName) == 0)
    {
        MP_ConfirmationDialog("Selection Error!", "You must first make a selection!"
                                                + "\nPlease select at least one node, then try again.", "ok");
    }
    else
    {
        for ( $node in $nodeName )
        {
            $numTokens = `tokenize $node "|" $buff`;
            $item = $buff[$numTokens - 1];
            
            switch($Option)
            {
              case "set":
                    if (`attributeExists "scrollUV" $node`){
                        if (`attributeExists "scrollU" $node`){
                            if ( $scrollU != 0 ){
                                setAttr ($node + ".scrollU") $scrollU;
                            }else{
                                setAttr ($node + ".scrollU") 0;
                            }
                        }else{
                            MP_UVScrolling("set");
                        }
                        
                        if (`attributeExists "scrollV" $node`){
                            if ( $scrollV != 0 ){
                                setAttr ($node + ".scrollV") $scrollV;
                            }else{
                                setAttr ($node + ".scrollV") 0;
                            }
                        }else{
                            MP_UVScrolling("set");
                        }
                        
                        if (`attributeExists "scrollR" $node`){
                            if ( $scrollR != 0 ){
                                setAttr ($node + ".scrollR") $scrollR;
                            }else{
                                setAttr ($node + ".scrollR") 0;
                            }
                        }else{
                            MP_UVScrolling("set");
                        }
                    }else{
                        addAttr -longName "scrollUV" -attributeType double3;
                        
                        if ( $scrollU != 0 ){
                            addAttr -longName "scrollU" -k true -defaultValue $scrollU -attributeType double -parent scrollUV;
                        }else{
                            addAttr -longName "scrollU" -k true -defaultValue 0 -attributeType double -parent scrollUV;
                        }
                        
                        if ( $scrollV != 0 ){
                            addAttr -longName "scrollV" -k true -defaultValue $scrollV -attributeType double -parent scrollUV;
                        }else{
                            addAttr -longName "scrollV" -k true -defaultValue 0 -attributeType double -parent scrollUV;
                        }
                        
                        if ( $scrollR != 0 ){
                            addAttr -longName "scrollR" -k true -defaultValue $scrollR -attributeType double -parent scrollUV;
                        }else{
                            addAttr -longName "scrollR" -k true -defaultValue 0 -attributeType double -parent scrollUV;
                        }
                    }
              break;
              
              case "get":
                    if (`attributeExists "scrollUV" $node`){
                        if (`attributeExists "scrollU" $node`){
                            floatField -edit -value `getAttr -asString ($node + ".scrollU")` scrollUFF;
                        }
                        if (`attributeExists "scrollV" $node`){
                            floatField -edit -value `getAttr -asString ($node + ".scrollV")` scrollVFF;
                        }
                        if (`attributeExists "scrollR" $node`){
                            floatField -edit -value `getAttr -asString ($node + ".scrollR")` scrollRFF;
                        }
                    }
              break;
              
              case "delete":
                    if (`attributeExists "scrollUV" $node`){
                        deleteAttr -attribute "scrollUV" -n $node;
                        floatField -edit -value 0 scrollUFF;
                        floatField -edit -value 0 scrollVFF;
                        floatField -edit -value 0 scrollRFF;
                    }
              break;
            }
        }
    }
}
///////////////////////////////////////////////////////////////
// Process: MP_GetEggObjectTypes                             //
// Retreives egg-object-types from selected node             //
///////////////////////////////////////////////////////////////
global proc MP_GetEggObjectTypes()
{
    /*
        Generate an array from any egg-object-types that are currently attached to the selected node.
        It then passes this array onto the MP_DeleteEggObjectTypesGUI process,
        to which it then displays them in button style in a separate window
        making it easier for a user to delete them from the selected node.
    */
    
    string $currentObjectTypesArray[];
    clear $currentObjectTypesArray;
    
        //Record the currently selected nodes
    string $selected[] =`ls -l -sl`;
    
        //Verify user has selected at least one node.
    if(size($selected) < 1){
            //Throw a message if at least one node has not been selected.
        MP_ConfirmationDialog("Selection Error!", "Nothing is currently selected"
                                                    + "\nSelect at least one node and try again.", "ok");
    }else{
            //Loop through each selected node to check for and gather any egg-object-type attributes
        for ($selection in $selected){
                //Attribute name we are checking for
            string $attributeName = "eggObjectTypes";
            
                //Insert current selected node hierarchy into array
            stringArrayInsertAtIndex(size($currentObjectTypesArray), $currentObjectTypesArray, $selection);
            
            for($i=1;$i<4;$i++){
                    //Check for attributes. If present, insert contents into array
                    //If not, insert dummy placeholder values
                if(`attributeExists ($attributeName + $i) $selection` == 1){
                        //Insert attribute value into array.
                        //Value is used for button label
                    stringArrayInsertAtIndex(size($currentObjectTypesArray) + 2
                                                ,$currentObjectTypesArray
                                                ,`getAttr -asString ($selection + "." + $attributeName + $i)`);
                }else{
                        //Insert 'NONE' attribute value into array
                    stringArrayInsertAtIndex(size($currentObjectTypesArray) + 2, $currentObjectTypesArray, "NONE");
                }
            }
        }
            
            //Send array of egg-object-types to MP_DeleteEggObjectTypesGUI
        MP_DeleteEggObjectTypesGUI($currentObjectTypesArray);
    }
}
///////////////////////////////////////////////////////////////
// Process: MP_DeleteEggObjectTypesGUI                       //
// Retreives egg-object-types from selected node             //
///////////////////////////////////////////////////////////////
global proc MP_DeleteEggObjectTypesGUI(string $currentObjectTypesArray[])
{
    /*
        Displays a separate GUI window listing.
        Each object-type a node has will be shown as a button.
        If a button is clicked, it will delete that object-type from the selected node and update the window.
    */
    
        //Delete any current instances of the MP_DeleteEggObjectTypesWindow window
    if (`window -exists MP_DeleteEggObjectTypesWindow`){
        deleteUI -window MP_DeleteEggObjectTypesWindow;
    }
    
        //Create the window layout
    window -retain -title "Delete Current Egg-Object-Types" -resizeToFitChildren true -sizeable 0 -visible 1 MP_DeleteEggObjectTypesWindow;
        frameLayout -backgroundColor 0.50 0.60 0.20
                    -collapsable false -font "obliqueLabelFont" -label "Egg-Object-Type Tags of selected nodes";
            columnLayout -adjustableColumn false -rowSpacing 0;
                rowLayout -nc 1 -rowAttach 1 "top" 0;
                    button -label "Update Window"
                            -width 110
                            -height 20
                            -annotation ("Refreshes the window with information on selected nodes"
                                        + "\nUsed if new nodes are selected while window is visible")
                            -command ("MP_GetEggObjectTypes")
                            MP_RefreshEggTypesWindowButton;
                setParent -u;
                rowLayout -nc 2 -rowAttach 1 "top" 0 -rowAttach 2 "top" 0;
                    columnLayout -width 150 -adjustableColumn false -rowSpacing 0 nodeColumn;
                        rowLayout -nc 1 -rowAttach 1 "top" 0 -columnAttach1 "left" -columnOffset1 15;
                            text -bgc 0.350 0.820 0.950 -label ("Node Name");
                        setParent -u;
                    setParent -u;
                    columnLayout -width 350 -adjustableColumn false rowColumn;
                        rowLayout -nc 3 -rowAttach 1 "top" 0 -rowAttach 2 "top" 0 -rowAttach 3 "top" 0
                                -columnAttach3 "left" "left" "left" -columnOffset3 30 65 65;
                            text -bgc 0.350 0.820 0.950 -label ("Egg Tag 1");
                            text -bgc 0.350 0.820 0.950 -label ("Egg Tag 2");
                            text -bgc 0.350 0.820 0.950 -label ("Egg Tag 3");
                        setParent -u;
                    setParent -u;
                setParent -u;
            setParent -u;
        setParent -u;
    showWindow MP_DeleteEggObjectTypesWindow;
    
    
    int $count = 0;
    for($n=0;$n<(size($currentObjectTypesArray))/4;$n++){
            //Parse out just the short node name as it is all we want for node labeling
        string $nodeHierarchy = $currentObjectTypesArray[$count];
            
            //Array variable to hold the split up tokens
        string $hierarchyTokens[];
        clear $hierarchyTokens;
        
            //Split node hierarchy into token segments
        tokenize($nodeHierarchy, "|", $hierarchyTokens);
        
            //Define $node name from the last token segment
        string $node = $hierarchyTokens[size($hierarchyTokens)-1];
        
            //Generate the node name label
        text -parent nodeColumn -font "boldLabelFont" -height 22 -label $node;
        
            //Increase our count
        $count++;
        
            //Create new row of buttons per node selected
            //One row will consist of node name label and up to three buttons.
            //Each button will depict an egg-object-type assigned to node.
        rowLayout -parent rowColumn -nc 3 -rowAttach ($n+1) "top" 0 ("rowLine" + $n);
        for($i=0;$i<3;$i++){
            string $eggType = $currentObjectTypesArray[$count];
            if($eggType != "NONE"){
                    //Create the button
                button -parent ("rowLine" + $n) -label $currentObjectTypesArray[$count]
                        -width 110
                        -height 20
                        -annotation ("Deletes the " + $currentObjectTypesArray[$count] 
                                        + " egg-object-type tag from the node")
                        -command ("MP_DeleteEggObjectType(\"" + $nodeHierarchy + "\", \"" + ($i+1) + "\")")
                        ($nodeHierarchy + ".eggObjectTypes" + ($i+1));
            }else{
                    //Create a dummy placeholder button
                button -parent ("rowLine" + $n) -label $eggType
                        -width 110
                        -height 20
                        -visible 1
                        -enable 0
                        -annotation ("")
                        -command ("")
                        ($nodeHierarchy + ".eggObjectTypes" + ($i+1));
            }
                    
                //Increase our count
            $count++;
        }
        setParent -u;
    }
    
        //Set window height: base height 51 + 20 per button row
    int $height = 51 + (($n * 2) + (($n + 1) * 20));
    window -edit -width 500 -height $height MP_DeleteEggObjectTypesWindow;
}
///////////////////////////////////////////////////////////////
// Process: MP_DeleteEggObjectType                           //
// Deletes the selected egg-object-type attribute from nodes //
///////////////////////////////////////////////////////////////
global proc MP_DeleteEggObjectType(string $nodeHierarchy, int $eggTypeAttributeNumber)
{
    /*
        Delete the clicked object-type from the selected node and update the window.
    */
    
    deleteAttr -attribute ("eggObjectTypes" + $eggTypeAttributeNumber) $nodeHierarchy;
    
        //Update the current egg-object-types window
    MP_GetEggObjectTypes();
}
///////////////////////////////////////////////////////////
// Process: MP_ArgsBuilder                               //
// constructs the arguments to pass to maya2egg          //
///////////////////////////////////////////////////////////
global proc string MP_ArgsBuilder(string $FileName)
{
    string $ARGS = "maya2egg";
    
    global string $gMP_MayaVersionShort;
    $ARGS += $gMP_MayaVersionShort;
    $ARGS += " ";

        //Increase output verbosity.  More v's means more verbose.
    $ARGS += "-v ";
    
        //We always want polygons, never nurbs.
    $ARGS += "-p ";
    
        //check back face culling i.e. 'double-sided faces'
    if(`checkBox -query -value MP_ExportBfaceCB`){
        $ARGS += "-bface ";
    }
        //check Shader option
    if(`checkBox -query -value MP_ExportLegacyShadersCB`){
        $ARGS += "-legacy-shaders ";
    }
        //check Keep UV option
    if(`checkBox -query -value MP_ExportKeepUvsCB`){
        $ARGS += "-keep-uvs ";
    }
        //check Round UV option
    if(`checkBox -query -value MP_ExportRoundUvsCB`){
        $ARGS += "-round-uvs ";
    }
        //check tbnall option  'Compute tangent and binormal for all texture coordinate sets'
    if(`checkBox -query -value MP_ExportTbnallCB`){
        $ARGS += "-tbnall ";
    }
        //check lights option  'Convert all light nodes to locators.'
    if(`checkBox -query -value MP_ExportLightsCB`){
        $ARGS += "-convert-lights ";
    }
        //check cameras option  'Convert all camera nodes to locators.'
    if(`checkBox -query -value MP_ExportCamerasCB`){
        $ARGS += "-convert-cameras ";
    }
        //check Export File Type option 'none, pose, flip, strobe, model, chan, or both'
    string $exportOptionsARGS = `radioCollection -query -select MP_ExportOptionsRC`;
    switch($exportOptionsARGS){
        case "MP_ChooseMeshRB":
            $ARGS += "-a none ";
        break;
        case "MP_ChooseActorRB":
            $ARGS += "-a model ";
        break;
        case "MP_ChooseAnimationRB":
            $ARGS += "-a chan ";
            
                //set the start frames
                //  **Does not check if start frame < end frame
                //  **Does not support negative values
                //  **Does not check if start/end frame is within bounds of the scene
            if(`radioCollection -query -select MP_AnimationOptionsRC` == "MP_chooseCustomAnimationRangeRB"){
                string $startFrameARGS = `intField -query -value MP_AnimationStartFrameIF`;
                string $endFrameARGS = `intField -query -value MP_AnimationEndFrameIF`;
                
                    //start frame
                if(`match "[0-9]+" $startFrameARGS` == $startFrameARGS && $startFrameARGS != ""){
                    $ARGS += ("-sf " + `match "[0-9]+" $startFrameARGS` + " ");
                }else{
                    error "Start Frame entered data is the wrong format.  Should be an integer.\n";
                    return "failed";
                }
                
                    //end frame
                if(`match "[0-9]+" $endFrameARGS` == $endFrameARGS && $endFrameARGS != ""){
                    $ARGS += ("-ef " + `match "[0-9]+" $endFrameARGS` + " ");
                }else{
                    error "End Frame entered data is the wrong format.      Should be an integer.\n";
                    return "failed";
                }
            }
        break;
        case "MP_ChooseBothRB":
            $ARGS += "-a both ";
            
              //set the start frames
              //  **Does not check if start frame < end frame
              //  **Does not support negative values
              //  **Does not check if start/end frame is within bounds of the scene
            if(`radioCollection -query -select MP_AnimationOptionsRC` == "MP_chooseCustomAnimationRangeRB"){
                string $startFrameARGS = `intField -query -value MP_AnimationStartFrameIF`;
                string $endFrameARGS = `intField -query -value MP_AnimationEndFrameIF`;
                
                    //start frame
                if(`match "[0-9]+" $startFrameARGS` == $startFrameARGS && $startFrameARGS != ""){
                    $ARGS += ("-sf " + `match "[0-9]+" $startFrameARGS` + " ");
                }else{
                    error "Start Frame entered data is the wrong format.  Should be an integer.\n";
                    return "failed";
                }
                
                    //end frame
                if(`match "[0-9]+" $endFrameARGS` == $endFrameARGS && $endFrameARGS != ""){
                    $ARGS += ("-ef " + `match "[0-9]+" $endFrameARGS` + " ");
                }else{
                    error "End Frame entered data is the wrong format.      Should be an integer.\n";
                    return "failed";
                }
            }
        break;
        case "MP_ChoosePoseRB":
            $ARGS += "-a pose ";

                //set the pose frame for animation
                //  **Does not support negative values
            string $startFrameARGS = `intField -query -value MP_AnimationStartFrameIF`;
            
            if(`match "[0-9]+" $startFrameARGS` == $startFrameARGS && $startFrameARGS != ""){
                $ARGS += ("-sf " + `match "[0-9]+" $startFrameARGS` + " ");
            }else{
                error "Start Frame entered data is the wrong format.  Should be an integer.\n";
                return "failed";
            }
        break;
    }
        //Get the 'transform mode' option and append to $ARGS string
    string $transformMode = `radioCollection -query -select MP_TransformModeRC`;
    switch($transformMode){
        case "MP_ChooseTransformModelRB":
            $ARGS += "-trans model ";
        break;
        case "MP_ChooseTransformAllRB":
            $ARGS += "-trans all ";
        break;
        case "MP_ChooseTransformDCSRB":
            $ARGS += "-trans dcs ";
        break;
        case "MP_ChooseTransformNoneRB":
            $ARGS += "-trans none ";
        break;
    }
        //Check status of remove groundPlane_transform checkBox
    if(`checkBox -query -value MP_RemoveGroundPlaneCB` == 1){
        $ARGS += "-exclude groundPlane_transform ";
    }
        //get scene up axis and append to $ARGS string
    string $up=`upAxis -q -axis`;
    $ARGS += "-cs " + $up + "-up ";
    
        //get units from option menu and append to $ARGS string
    string $unit=`optionMenu -q -value MP_UnitMenu`;
    $ARGS += "-uo " + $unit + " ";
      
        /*  -cn name
            Specifies the name of the animation character.  This
            should match between all of the model files and all of
            the channel files for a particular model and its
            associated channels.
            Only applied if the exported file is not a mesh type.
        */
    if($exportOptionsARGS != "MP_ChooseMeshRB"){
            //User has entered a character name, we use that
        if(`textField -query -text MP_CharacterNameTF` != ""){
                //spaces not allowed, replace with underscores
            $ARGS += "-cn " + substituteAllString(`textField -query -text MP_CharacterNameTF`, " ", "_") + " ";
        }else{
                //User did not enter a character name, we use file name as character name
                //spaces not allowed, replace with underscores
            $ARGS += "-cn " + substituteAllString($FileName, " ", "_") + " ";
        }
    }

        /*  -force-joint name
            Specifies the name(s) of a DAG node that maya2egg should
            treat as a joint, even if it does not appear to be a 
            Maya joint and does not appear to be animated.
            The specified DAGs have to be tagged as a DCS egg-type.
            Routine checks for this and if it doesn't exist, it adds the DCS tag to it.
        */
    int $mustRestart = 0;
    string $joints[];
    string $JointNames = `textField -query -text MP_ForceJointTF`;
    int $numberEntries = `tokenize $JointNames " " $joints`;
    
    if(`textField -query -text MP_ForceJointTF` != ""){
            //iterate through each named joint and verify they have the required 'DCS' object-type flag set
            //If not, we add the attribute and request restarting the export process
            //We MUST restart so the export process recognizes the added object-tags
        for($i=0;$i<$numberEntries;$i++){
            string $eggObjectTypes1 = "", $eggObjectTypes2 = "", $eggObjectTypes3 = "";
            select -r $joints[$i];
            if(`attributeExists "eggObjectTypes1" $joints[$i]` == 1){
                $eggObjectTypes1 = `getAttr -asString ($joints[$i] + ".eggObjectTypes1")`;
            }
            
            if(`attributeExists "eggObjectTypes2" $joints[$i]` == 1){
                $eggObjectTypes2 = `getAttr -asString ($joints[$i] + ".eggObjectTypes2")`;
            }
            
            if(`attributeExists "eggObjectTypes3" $joints[$i]` == 1){
                $eggObjectTypes3 = `getAttr -asString ($joints[$i] + ".eggObjectTypes3")`;
            }
            
                //If any of the current object-type attributes are DCS, append to $ARGS
                //If there is no DCS attribute, add it to the node
            if(($eggObjectTypes1 == "dcs") || ($eggObjectTypes2 == "dcs") || ($eggObjectTypes3 == "dcs")){
                $ARGS += "-force-joint " + $joints[$i] + " ";
            }else{
                MP_AddEggObjectFlags("dcs");
                $mustRestart += 1;
            }
        }
          
          //If $mustRestart variable is greater than 0, we had to add a DCS tag.
          //If we had to add a DCS tag to any nodes, we must restart exporting so it's recognized.
          //Otherwise, the force-joint for that node will not export properly.
        if($mustRestart != 0){
                //Prompt user with confirm dialog if we had to add the DCS attribute to any of the nodes
            string $confirmRestart = MP_ConfirmationDialog("File Error!", "We had to add a missing DCS flag to one or more of the \"-force-joint\" nodes."
                                                                            + "\nWe must restart the exporting process now."
                                                                            + "\nPress 'Yes' to restart, Press 'No' to exit exporting", "yesno");
            if($confirmRestart == "YES"){
                MP_StartSceneExport();
                return "failed"; //needed to exit the previous exporting loop
            }else{
                error "User cancelled exporting";
                return "failed";
            }
        }
    }
    
        //Check custom reference path and output path; append to $ARGS string
        //-ps   The option may be one of: rel, abs, rel_abs, strip, or keep. If either rel or rel_abs is specified,
        //      the files are made relative to the directory specified by -pd.  The default is rel.
        
        //Check if we are referencing textures to a path OTHER than the Maya file
    if(`radioCollection -query -select MP_TexPathOptionsRC` != "MP_ChooseDefaultTexPathRB"){
        $ARGS += ("-ps rel" + " ");
    }
        
        //-pd   Specifies the name of a directory to make paths relative to, if '-ps rel' or '-ps rel_abs' is specified.
        //      If this is omitted, the directory name is taken from the name of the output file.
        
        //-pp   Adds the indicated directory name to the list of directories to search for filenames referenced by the source file.
        //      We always want to add the file path to the search
    
        //-pc   Copies textures and other dependent files into the indicated directory.
        //      If a relative pathname is specified, it is relative to the directory specified with -pd, above.
        
        
        //Check if we are referencing textures to a Custom path
    string $customTexPath = `textField -query -text MP_CustomEggTexPathTF`;
    if(`radioCollection -query -select MP_TexPathOptionsRC` == "MP_ChooseCustomRefPathRB"){
            //If we are exporting to an Egg File and Bam File, THE EGG MUST BE RELATIVE TO MAYA FILE!!
            //So we skip this.
            //Otherwise the bam file will be produced without textures since it can't find them during compiling
            //  NOTE: Bam file texture referencing is handled in the MP_Export2Bam process
            //If exporting only to an Egg File, relative referencing will function as expected
            //  and directory path MUST start with the path to where the textures are truly located
        if(`radioCollection -query -select MP_OutputPandaFileTypeRC` == "MP_ChooseEggRB"){
                //Verify user entered in a path
            if($customTexPath != ""){
                $ARGS += ("-pd " + "\"" + $customTexPath + "\"" + " ");
                $ARGS += ("-pp " + "\"" + $customTexPath + "\"" + " ");
            }
        }
    }
    
        //Check if we are copying and referencing textures to a Custom path
    string $customOutputPath = `textField -query -text MP_CustomOutputPathTF`;
    if(`radioCollection -query -select MP_TexPathOptionsRC` == "MP_ChooseCustomTexPathRB"){
        if($customTexPath != ""){
            $ARGS += ("-pc " + "\"" + $customTexPath + "\"" + " ");
            $ARGS += ("-pp " + "\"" + $customTexPath + "\"" + " ");
        }
        
        if($customOutputPath != ""){
            $ARGS += ("-pd " + "\"" + $customOutputPath + "\"" + " ");
        }
    }
    
    print ("Using these arguments: " + $ARGS + "[END]\n");
    return $ARGS;
}
///////////////////////////////////////////////////////////
// Process: MP_StartSceneExport                          //
///////////////////////////////////////////////////////////
global proc int MP_StartSceneExport()
{
        /*
            We need to do before calling MP_Export2Egg/BAM/Pview:
            -Export a temporary MB
            -Get the destination path
            -Get the filename
            -Get the custom arguments
        */
    string $tempMBFile = "";
    if(`checkBox -query -value MP_ExportSelectedCB`){
        $tempMBFile = MP_ExportScene("selected");  //returns $tempScenePath as $tempMBFile
        if($tempMBFile == "failed"){
            return 0;
        }
    }else{
        $tempMBFile = MP_ExportScene("all");  //returns $tempScenePath as $tempMBFile
        if($tempMBFile == "failed"){
            return 0;
        }
    }

        //Determine base file name from the scene name.
    string $origFileName = basenameEx(`file -q -sceneName`);

        /*
            Get the destination path
            Get the filename
            Get the custom arguments
        */
    string $eggFile = MP_ExportPrep($tempMBFile, $origFileName);
    
        //Delete the temporary Maya binary file
    //sysFile -del $tempMBFile;
    
        //Check if the eggFile passed return, else return it failed as an integer
    if($eggFile == "failed"){
        return 0;
    }else{
        return 1;
    }
}
///////////////////////////////////////////////////////////
// Process: MP_ExportScene                               //
// exports the entire scene/selected objects             //
///////////////////////////////////////////////////////////
global proc string MP_ExportScene(string $selection)
{
    string $scenePath = dirname(`file -q -sceneName`);  //gets the current scene filename and path if present.
    string $fileName = basenameEx(`file -q -sceneName`);  //cut off the file extension
    string $fileExtension = fileExtension(`file -q -sceneName`); //Returns file extension
    
    string $tempScenePath = "";
    
        //Processes if exporting file with original file name and default output path
    if((`radioCollection -query -select MP_OutputFilenameOptionsRC` == "MP_ChooseOriginalFilenameRB") &&
        (`radioCollection -query -select MP_OutputPathOptionsRC` == "MP_ChooseDefaultOutputPathRB")){
        if(($scenePath == "")||($fileName == "")){
            MP_ConfirmationDialog("File Error!", "It appears you have not yet saved this scene. Please save your scene first"
                                                    + "\nOR, specify a Custom Output Directory AND Custom Filename.", "ok");
            return "failed";
        }else{
            $tempScenePath = ($scenePath + "/" + $fileName + "_temp.mb");
        }
    }
      
        //Processes if exporting file with original file name and custom output path
    if((`radioCollection -query -select MP_OutputFilenameOptionsRC` == "MP_ChooseOriginalFilenameRB") &&
        (`radioCollection -query -select MP_OutputPathOptionsRC` == "MP_ChooseCustomOutputPathRB")){
        if($fileName == ""){
            MP_ConfirmationDialog("File Error!", "It appears you have not yet saved this scene. Please save your scene first"
                                                    + "\nOR, specify a Custom Output Directory AND Custom Filename.", "ok");
            return "failed";
        }else{
            string $TempPath = `textField -query -text MP_CustomOutputPathTF`;
            if($TempPath == ""){
                MP_ConfirmationDialog("File Error!", "It appears you have not entered a Custom Path."
                                                        + "\nPlease Enter a Custom Path and then try Exporting again", "ok");
                return "failed";
            }else{
                $tempScenePath = ($TempPath + "/" + $fileName + "_temp.mb");
            }
        }
    }
    
      //Processes if exporting file with custom file name and default output path
    if((`radioCollection -query -select MP_OutputFilenameOptionsRC` == "MP_ChooseCustomFilenameRB") &&
        (`radioCollection -query -select MP_OutputPathOptionsRC` == "MP_ChooseDefaultOutputPathRB")){
        if($scenePath == ""){
            MP_ConfirmationDialog("File Error!", "It appears you have not yet saved this scene. Please save your scene first"
                                                    + "\nOR, specify a Custom Output Directory AND Custom Filename.", "ok");
            return "failed";
        }else{
            string $tempFileName = `textField -query -text MP_CustomFilenameTF`;
            if($tempFileName == ""){
                MP_ConfirmationDialog("File Error!", "It appears you have not entered a Custom File Name."
                                                        + "\nPlease Enter a Custom Name and then try Exporting again", "ok");
                return "failed";
            }else{
                $tempScenePath = ($scenePath + "/" + $tempFileName + "_temp.mb");
            }
        }
    }
    
      //Processes if exporting file with custom file name and custom output path
    if((`radioCollection -query -select MP_OutputFilenameOptionsRC` == "MP_ChooseCustomFilenameRB") &&
        (`radioCollection -query -select MP_OutputPathOptionsRC` == "MP_ChooseCustomOutputPathRB")){
        string $TempPath = `textField -query -text MP_CustomOutputPathTF`;
        if($TempPath == ""){
            MP_ConfirmationDialog("File Error!", "It appears you have not entered a Custom Path."
                                                    + "\nPlease Enter a Custom Path and then try Exporting again", "ok");
            return "failed";
        }else{
            string $tempFileName = `textField -query -text MP_CustomFilenameTF`;
            if($tempFileName == ""){
                MP_ConfirmationDialog("File Error!", "It appears you have not entered a Custom File Name."
                                                        + "\nPlease Enter a Custom Name and then try Exporting again", "ok");
                return "failed";
            }else{
                $tempScenePath = ($TempPath + "/" + $tempFileName + "_temp.mb");
            }
        }
    }
    
        //Export entire scene contents
    if($selection == "all"){
        print "Exporting scene...\n";
        file -op "v=1" -typ "mayaBinary" -ea $tempScenePath;  //export the whole scene
        print ("Saved entire scene as temporary file: " + $tempScenePath + "\n");
    }else{
            //Export selected scene contents
        print "Exporting scene...\n";
        file -op "v=1" -typ "mayaBinary" -es $tempScenePath;  //export only selected objects
        print ("Saved selected objects as temporary file: " + $tempScenePath + "\n");
    }

    return $tempScenePath;
}
///////////////////////////////////////////////////////////
// Process: MP_ExportPrep                                //
///////////////////////////////////////////////////////////
global proc string MP_ExportPrep(string $workFile, string $fileName)
{
    //Received variables: $workFile("full file path and name"), $fileName("base file name")
    
        //Get the destination path
    string $destPath = dirname($workFile) + "/";
        
        //Custom File Name Option
    string $customFilename = `textField -query -text MP_CustomFilenameTF`;
    if($customFilename != ""){
        $fileName = $customFilename;
    }
        
        //Get the custom arguments
    string $ARGS = MP_ArgsBuilder($fileName);

    if($ARGS == "failed"){
        return "failed";
    }

        //export the egg
    string $eggFile = MP_Export2Egg($workFile, $destPath, $fileName + ".egg", $ARGS);
    if($eggFile == "failed"){
        return "failed";
    }

        //run egg2bam if bam file output option is selected
    if(`radioCollection -query -select MP_OutputPandaFileTypeRC` == "MP_ChooseEggBamRB"){
        MP_Export2Bam($eggFile, 0);
    }else{
            //run pview if option is selected
        if(`checkBox -query -value MP_ExportPviewCB`){
            MP_Send2Pview ($eggFile);
        }
    }
    
    return $eggFile;
}
///////////////////////////////////////////////////////////
// Process: MP_Export2Egg                                //
///////////////////////////////////////////////////////////
global proc string MP_Export2Egg(string $mbfile, string $destPath, string $destFilename, string $ARGS)
{
        //Check if there is a valid maya binary file to operate on
    if($mbfile == ""){
        error "Not a valid Maya Binary file.";
        return "failed";
    }else{
        //Start export process
            //make the final egg path
        string $eggFile = ($destPath + $destFilename);
        
        print ("Your scene will be saved as this egg file: " + $destFilename + "\n");
        print ("In this directory: " + $destPath + "\n");

          //Check if overwriting is enabled
        if(`checkBox -query -value MP_ExportOverwriteCB`){
                //Overwrite
            print "!!Overwrite enabled!!\n";

            string $result =
                system
                (
                    $ARGS
                    + " -o "
                    + "\"" + $eggFile + "\""
                    + " "
                    + "\"" + $mbfile + "\""
                );
            print ($result + "\n");
        }else{
                //Don't overwrite
            string $result =
                system
                (
                    $ARGS
                    + "\"" + $mbfile + "\""
                    + " "
                    + "\"" + $eggFile + "\""
                );
            print ($result + "\n");
        }
            
        print ("Finished exporting (.mb -> .egg), unit : " + `optionMenu -q -value MP_UnitMenu` + "\n");
        return $eggFile;
    }
}
///////////////////////////////////////////////////////////
// Process: MP_Export2Bam                                //
// used by main exporting script                         //
///////////////////////////////////////////////////////////
global proc MP_Export2Bam(string $eggFile, int $exportMode)
{
        /*
            Check if there is a valid egg file to operate on
            Cannot operate without an egg first and we throw
            an error if the scene has no associated egg file
            
            $exportMode options:
                0 = normal scene exporting
                1 = User has chosen a specific egg file to bam up
        */
    if($eggFile == ""){
        error "Invalid egg file";
    }else{
            //process functions then call egg2bam
        string $fileName = basenameEx($eggFile);
        string $fileExtension = fileExtension($eggFile);
        string $filePath = dirname($eggFile);
            //Check for Bam Output Option '-rawtex'
        string $rawTex = "";
        if(`checkBox -query -value MP_RawtexCB`){
            $rawTex = "-rawtex ";
        }
            //Check for Bam Output Option '-flatten'
        string $flatten = "";
        if(`checkBox -query -value MP_FlattenCB`){
            $flatten = "-flatten 1 ";
        }
            //-ps   The option may be one of: rel, abs, rel_abs, strip, or keep. If either rel or rel_abs is specified,
            //      the files are made relative to the directory specified by -pd.  The default is rel.
        string $pathStore = "";
            //-pd   Specifies the name of a directory to make paths relative to, if '-ps rel' or '-ps rel_abs' is specified.
            //      If this is omitted, the directory name is taken from the name of the output file.
        string $pathDirectory = "";
            //-pp   Adds the indicated directory name to the list of directories to search for filenames referenced by the source file.
            //      We always want to add the file path to the search
        string $dirname = "";
            //-pc   Copies textures and other dependent files into the indicated directory.
            //      If a relative pathname is specified, it is relative to the directory specified with -pd, above.
        string $targetDirectory = "";
            //$exportMode options:
            //    0 = normal scene exporting
            //    1 = User has chosen a specific egg file to bam up
        if($exportMode == 1){
                //Custom File Name Option
            string $customFilename = `textField -query -text MP_CustomFilenameTF`;
            if($customFilename != ""){
                $fileName = $customFilename;
            }
                
                //Custom Output Path Option
            string $customOutputPath = `textField -query -text MP_CustomOutputPathTF`;
            if($customOutputPath != ""){
                $filePath = $customOutputPath;
            }
        }    
            //Custom Texture Referencing Options
        if(`radioCollection -query -select MP_TexPathOptionsRC` == "MP_ChooseCustomRefPathRB"){
                //Get the setting for the file type as it changes which textFields we will use
            string $outputPandaFileType = `radioCollection -query -select MP_OutputPandaFileTypeRC`;
            string $customBamTexPath = `textField -query -text MP_CustomBamTexPathTF`;
            string $customEggTexPath = `textField -query -text MP_CustomEggTexPathTF`;
            $pathStore = ("-ps rel ");
            
            switch($outputPandaFileType){
                case "MP_ChooseEggRB":
                        //Make exception if user failed to enter in a path
                    if($customEggTexPath != ""){
                        $pathDirectory += ("-pd " + "\"" + $customEggTexPath + "\"" + " ");
                    }else{
                        $pathDirectory += ("-pd " + "\"" + $filePath + "\"" + " ");
                    }
                    
                    $dirname += ("-pp " + "\"" + $filePath + "\"" + " ");
                break;
                case "MP_ChooseEggBamRB":
                        //Make exception if user failed to enter in a path
                    if($customBamTexPath != ""){
                        $pathDirectory += ("-pd " + "\"" + $customBamTexPath + "\"" + " ");
                    }else{
                        $pathDirectory += ("-pd " + "\"" + $filePath + "\"" + " ");
                    }
                    
                    $dirname += ("-pp " + "\"" + $filePath + "\"" + " ");
                break;
            }
        }
            //Copy Textures to and Make Relative Options
        if(`radioCollection -query -select MP_TexPathOptionsRC` == "MP_ChooseCustomTexPathRB"){
                //Get the setting for the file type as it changes which textFields we will use
            string $outputPandaFileType = `radioCollection -query -select MP_OutputPandaFileTypeRC`;
            string $customBamTexPath = `textField -query -text MP_CustomBamTexPathTF`;
            string $customEggTexPath = `textField -query -text MP_CustomEggTexPathTF`;
            $pathStore = ("-ps rel ");
            
            switch($outputPandaFileType){
                case "MP_ChooseEggRB":
                            //Define path to make relative to
                        $pathDirectory += ("-pd " + "\"" + $filePath + "\"" + " ");
                            //Only copy textures if we called an egg file to bam up.
                            //Otherwise, they get copied when exporting scene normally
                        if($exportMode == 1){
                                //Make exception if user failed to enter in a path
                            if($customEggTexPath != ""){
                                $targetDirectory += ("-pc " + "\"" + $customEggTexPath + "\"" + " ");
                            }else{
                                    //Define copy-to directory
                                $targetDirectory += ("-pc " + "\"" + $filePath + "\"" + " ");
                            }
                        }
                            //Add file path to search path
                        $dirname += ("-pp " + "\"" + $filePath + "\"" + " ");
                break;
                case "MP_ChooseEggBamRB":
                            //Make exception if user failed to enter in a path
                        if($customBamTexPath != ""){
                                //Define path to make relative to
                            $pathDirectory += ("-pd " + "\"" + $customBamTexPath + "\"" + " ");
                        }else{
                                //Define path to make relative to
                            $pathDirectory += ("-pd " + "\"" + $filePath + "\"" + " ");
                        }
                            //Only copy textures if we called an egg file to bam up.
                            //Otherwise, they get copied when exporting scene normally
                        if($exportMode == 1){
                                //Make exception if user failed to enter in a path
                            if($customEggTexPath != ""){
                                $targetDirectory += ("-pc " + "\"" + $customEggTexPath + "\"" + " ");
                            }else{
                                    //Define copy-to directory
                                $targetDirectory += ("-pc " + "\"" + $filePath + "\"" + " ");
                            }
                        }
                            //Add file path to search path
                        $dirname += ("-pp " + "\"" + $filePath + "\"" + " ");
                break;
            }
        }
            //Define full bam file path and name
        string $bamFile = $filePath + "/" + $fileName + ".bam";
        print ("Your file is: " + $fileName + "." + $fileExtension + "\nFound in path: " + $filePath + "/" + "\n\n");
        print ("Your bam file to be saved as: " + $bamFile + "\n");

        string $egg2bam = MP_PandaVersion("getEgg2Bam");  //returns egg2bam version
            //Check if overwriting is enabled or not, and call egg2bam to create the file
        if(`checkBox -query -value MP_ExportOverwriteCB`){
                //Overwrite Mode
            string $result =
                system(
                    $egg2bam + " "  + $rawTex + $flatten
                                    + $pathStore
                                    + $pathDirectory
                                    + $targetDirectory
                                    + $dirname
                                    + "-o "
                                    + "\"" + $bamFile + "\""
                                    + " "
                                    + "\"" + $eggFile + "\""
                );
            
                //Do some formatting only for the printing of selected options so they better fit into the script editor window
            if($pathStore != ""){
                $pathStore = ("\n" + $pathStore);
            }
            if($pathDirectory != ""){
                $pathDirectory = ("\n" + $pathDirectory);
            }
            if($targetDirectory != ""){
                $targetDirectory = ("\n" + $targetDirectory);
            }
            if($dirname != ""){
                $dirname = ("\n" + $dirname);
            }
            
            print ("Using these options:\n" + $egg2bam + " " + $rawTex + $flatten
                                            + $pathStore
                                            + $pathDirectory
                                            + $targetDirectory
                                            + $dirname
                                            + "\n-o " + $bamFile
                                            + "\n" + $eggFile + "\n");
        }else{
                    //Don't Overwrite Mode
            string $result =
                system(
                    $egg2bam + " "  + $rawTex + $flatten
                                    + $pathStore
                                    + $pathDirectory
                                    + $targetDirectory
                                    + $dirname
                                    + "\"" + $eggFile + "\""
                                    + " "
                                    + "\"" + $bamFile + "\""
                );
                
                //Do some formatting only for the printing of selected options so they better fit into the script editor window
            if($pathStore != ""){
                $pathStore = ("\n" + $pathStore);
            }
            
            if($pathDirectory != ""){
                $pathDirectory = ("\n" + $pathDirectory);
            }
            
            if($targetDirectory != ""){
                $targetDirectory = ("\n" + $targetDirectory);
            }
            
            if($dirname != ""){
                $dirname = ("\n" + $dirname);
            }
            
            print ("Using these options:\n" + $egg2bam + " " + $rawTex + $flatten
                                            + $pathStore
                                            + $pathDirectory
                                            + $targetDirectory
                                            + $dirname
                                            + "\n" + $eggFile
                                            + "\n" + $bamFile + "\n");
        }
            
            //run pview if option is selected
        if(`checkBox -query -value MP_ExportPviewCB`){
            MP_Send2Pview($bamFile);
        }
    }
    
    print ("Finished converting (.egg -> .bam), unit : " + `optionMenu -q -value MP_UnitMenu` + "\n");
}
///////////////////////////////////////////////////////////
// Process: MP_ExportNodesToPandaFiles                   //
// Process that converts multiple selections in a scene  //
// to either eggs or egg and bam files at one time.      //
///////////////////////////////////////////////////////////
global proc MP_ExportNodesToPandaFiles()
{
        /*
            Converts the selected node or nodes to Panda files. Supports multiple selected nodes.
            Exports each selected node as its own set of files in the user selected output folder.
            The user may pre-select the output folder by using the "Export to other directory:" in the 'Output File Path' GUI section
            before clicking the the 'Convert Nodes To Panda' button, otherwise, the user will be prompted for the output folder.
            A custom output folder path MUST be used for this process.
            
            The default is to export the Maya binary file and to generate an egg file,
            however, if 'EGG(ASCII) and BAM(Binary)' is currently selected
            the process will generate all three files in the chosen output directory."
            The process of generating a bam file, if chosen, will utilize the current bam export options, including the bam version chosen.
        */
        
        //Get the export directory path
    string $destPath = `textField -query -text MP_CustomOutputPathTF`;
    string $selectedNodes[] =`ls -l -sl`;
    sort($selectedNodes);
    
    if(size($selectedNodes) < 1){
        MP_ConfirmationDialog("Selection Error!", "You must select at least one(1) node to export.", "ok");
    }else{
        if($destPath == ""){
            string $outputDirectoryError = MP_ConfirmationDialog("Output Directory ERROR!", "You must select a directory where the exported files will go."
                                                                                            + "\nclick \"Choose Directory\" to select the directory and continue"
                                                                                            + "\nor click \"Cancel\" to exit process.", "selectcancel");
            if($outputDirectoryError == "SELECT"){
                radioButton -edit -select MP_ChooseCustomOutputPathRB;
                MP_BrowseForFolderPreProcess("customOutputPath");
                MP_ExportNodesToPandaFiles();
            }
        }else{
                //Add directory path level divider backslash to end of the $destPath
            $destPath += "/";
                //Variable to hold namespace tokens
            string $buffer[];
                //Variable to keep track of number of exported files
            int $filesExported = 0;
                //Variable Array that will contain the listing of exported nodes to files with their output path,
                //  which will be displayed to the user once all the node exporting has completed.
            string $nodesToPandaFiles[];
            clear $nodesToPandaFiles;
            
                //Variable defining how many nodes were selected
            int $numberOfSelectedNodes = size($selectedNodes);
            
                //This variable is defined on maya startup
            global string $gMainProgressBar;
                
                //Create and initialize the main GUI progress bar
            progressBar -edit
                        -beginProgress
                        -isInterruptable true
                        -minValue 0
                        -maxValue $numberOfSelectedNodes
                        $gMainProgressBar;
            
                //Variable used for loop counting
            int $thisFileNumber = 1;
            
            for ($node in $selectedNodes){
                    //Define process break method if escape is depressed during processing
                if(`progressBar -query -isCancelled $gMainProgressBar`){
                    //$filesExported = 0;
                    break;
                }else{
                        //Update our progress bar
                    progressBar -edit
                                -step 1
                                -status ("Exporting selected node... " + $thisFileNumber + " of Nodes: " + $numberOfSelectedNodes)
                                $gMainProgressBar;
                    
                    int $Tokens = `tokenize $node "|" $buffer`;
                    int $number = ($Tokens - 1);
                        // make the temp files
                    select -r $node;
                    string $mayaFileName = ($buffer[$number] + ".mb");
                    string $tempMBFile = ($destPath + $mayaFileName);
                    file -op "v=1" -typ "mayaBinary" -es ($tempMBFile);
                        //Insert the Maya file name into the array
                    stringArrayInsertAtIndex(size($nodesToPandaFiles), $nodesToPandaFiles, $mayaFileName);
                        //Insert the Maya file path into the array
                    stringArrayInsertAtIndex(size($nodesToPandaFiles), $nodesToPandaFiles, $destPath);
                        // make the output egg filename
                    string $FileName = basenameEx($tempMBFile);
                    string $destFilename = $FileName + ".egg";
                        // Get the custom arguments
                    string $ARGS = MP_ArgsBuilder($FileName);
                        // based on option button checked, output only egg or both egg and bam files.
                        //export the Maya file and an egg file
                    if(`radioCollection -query -select MP_OutputPandaFileTypeRC` == "MP_ChooseEggRB"){
                            // export the egg
                        string $eggFile = MP_Export2Egg($tempMBFile, $destPath, $destFilename, $ARGS);
                            //Insert the file name into the array
                        stringArrayInsertAtIndex(size($nodesToPandaFiles), $nodesToPandaFiles, $destFilename);
                            //Insert the file path into the array
                        stringArrayInsertAtIndex(size($nodesToPandaFiles), $nodesToPandaFiles, $destPath);
                             //Increase variable to keep track of number of exported files
                        $filesExported++;
                    }else if(`radioCollection -query -select MP_OutputPandaFileTypeRC` == "MP_ChooseEggBamRB"){
                          //export the Maya file, a bam file and an egg file
                            //export the egg
                        string $eggFile = MP_Export2Egg($tempMBFile, $destPath, $destFilename, $ARGS);
                            //Insert the egg file name into the array
                        stringArrayInsertAtIndex(size($nodesToPandaFiles), $nodesToPandaFiles, $destFilename);
                            //Insert the egg file path into the array
                        stringArrayInsertAtIndex(size($nodesToPandaFiles), $nodesToPandaFiles, $destPath);
                            //Convert egg file to a bam file using egg2bam of version selected.
                        MP_Export2Bam($eggFile, 0);
                            //Define the bam file name based on egg file name
                            //This section only used for adding file names to the array
                        string $bamFileName = (basenameEx($tempMBFile) + ".bam");
                            //Insert the bam file name into the array
                        stringArrayInsertAtIndex(size($nodesToPandaFiles), $nodesToPandaFiles, $bamFileName);
                            //Insert the bam file path into the array
                        stringArrayInsertAtIndex(size($nodesToPandaFiles), $nodesToPandaFiles, $destPath);
                            //Increase variable to keep track of number of exported files
                        $filesExported++;
                    }
                }
                    //Increase loop counter
                $thisFileNumber++;
            }
            
                //Destroy the progress bar
            progressBar -edit -endProgress $gMainProgressBar;
            
            if(($filesExported > 0) && (size($nodesToPandaFiles) > 0)){
                MP_NodesExportedAsPandaFilesGUI($nodesToPandaFiles);
            }
        }
    }
}
///////////////////////////////////////////////////////////////
// Process: MP_NodesExportedAsPandaFilesGUI                  //
// Process to generate a window showing exported panda files //
///////////////////////////////////////////////////////////////
global proc MP_NodesExportedAsPandaFilesGUI(string $nodesToPandaFiles[])
{
        /*
            This process displays all the nodes that were exported as Panda files.
            The process is run automatically after exporting Maya nodes to Panda files.
            It displays the file names and the location they were exported to as a reference to the user.
        */
    
        // Delete list window if it's currently open, to reset it.
    if (`window -exists MP_NodesExportedToPandaFilesGUI` == 1){
        deleteUI -window MP_NodesExportedToPandaFilesGUI;
    }
    
    if(size($nodesToPandaFiles) == 0){
        MP_ConfirmationDialog("Data Error!", "There is currently no exported files in the array.", "ok");
    }else{
        window -sizeable false -width 600 -height 200
                -title "...Listing of Exported nodes to Panda Files..."
                -toolbox true -titleBarMenu true MP_NodesExportedToPandaFilesGUI;
            
            columnLayout -columnAttach "left" 0 -adjustableColumn true -rowSpacing 0;
                scrollField -width 600 -height 200 -wordWrap false -editable false MP_ExportedPandaFilesScrollField;
            setParent -u;
        
        showWindow MP_NodesExportedToPandaFilesGUI;
        
        window -edit -width 600 -height 200 MP_NodesExportedToPandaFilesGUI;
        int $count = 0;
        
        for($i=0;$i<(size($nodesToPandaFiles)/2);$i++){
            scrollField -edit -insertionPosition 0 -insertText ($nodesToPandaFiles[$count] + " : "
                                                                + $nodesToPandaFiles[$count+1]
                                                                + "\n")
                                                                MP_ExportedPandaFilesScrollField;
            $count = $count + 2;
        }
    }
}
///////////////////////////////////////////////////////////
// Process: MP_Bam2Egg                                   //
// used by main exporting script and for                 //
// User choosing an egg file to perform egg2bam on       //
///////////////////////////////////////////////////////////
global proc MP_Bam2Egg(string $bamFile)
{
        //Check if there is a valid bam file to operate on
    if($bamFile == ""){
            //Cannot operate without a bam file first
            //throw error if the scene has no associated bam file
        error "Invalid bam file";
    }else{
            //get variables and call bam2egg executable
        string $eggFile = "";
        string $fileName = basenameEx($bamFile);
        string $fileExtension = fileExtension($bamFile);
        string $filePath = dirname($bamFile);
            //Use either the original fileName or custom fileName for the output
        if(`radioCollection -query -select MP_OutputFilenameOptionsRC` == "MP_ChooseCustomFilenameRB"){
                //Verify user has entered in a custom file name
            if(`textField -query -text MP_CustomFilenameTF` != ""){
                $eggFile = $filePath + "/" + `textField -query -text MP_CustomFilenameTF` + ".egg";
            }else{
                error "Invalid custom file name! Please enter a name and try exporting again.";
            }
        }else{
            $eggFile = $filePath + "/" + $fileName + ".egg";
        }

        string $bam2egg = MP_PandaVersion("getBam2Egg");  //returns versioned bam2egg executable
        print ("Your file is: " + $fileName + "." + $fileExtension + "\nFound in path: " + $filePath + "/" + "\n\n");
        print ("Your file will be saved as this egg file: " + $eggFile + "\n");
        
            //Verify our eggFile has been set
        if($eggFile != ""){
                //Check if overwriting is enabled or not
            if(`checkBox -query -value MP_ExportOverwriteCB`){
                    //Overwrite Mode
                string $result =
                    system(
                        $bam2egg + " -o "
                        + "\"" + $eggFile + "\""
                        + " "
                        + "\"" + $bamFile + "\""
                    );
                print ($result + "\n");
            }else{
                    //Don't Overwrite Mode
                string $result =
                    system(
                        $bam2egg + " "
                        + "\"" + $bamFile + "\""
                        + " "
                        + "\"" + $eggFile + "\""
                    );
                print ($result + "\n");
            }
            print ("Finished converting (.bam -> .egg)");
        }
    }
}
///////////////////////////////////////////////////////////////
// Process: MP_BrowseForFilePreProcess                       //
// Passes specific variables to the MP_BrowseForFile process //
///////////////////////////////////////////////////////////////
global proc MP_BrowseForFilePreProcess(string $option)
{
        /*
            This process is used when we need to have user choose a file or files
            We subsequently update specific textFields in the process.
            This process is currenlty only utilized when the button is clicked,
            otherwise, we call MP_BrowseForFile directly from other processes.
            
            filemode return values.
            0 Any file, whether it exists or not.
            1 A single existing file.
            2 The name of a directory. Both directories and files are displayed in the dialog.
            3 The name of a directory. Only directories are displayed in the dialog.
            4 The names of one or more existing files.
        */
    
    switch($option){
        case "customFilename":
                int $fileMode = 0;
                string $caption = "Select file name to save as";
                string $fileFilter = ("Panda Egg (*.egg);;All Files  (*.*)");
                string $startingDirectory = dirname(`file -q -sn`);
                string $customFile[] = MP_BrowseForFile($fileMode, $caption, $startingDirectory, $fileFilter);
                string $fileName = basenameEx($customFile[0]);
                string $directoryName = dirname($customFile[0]);
                textField -edit -enable 1 -text $fileName MP_CustomFilenameTF;
                radioButton -edit -select MP_ChooseCustomOutputPathRB;
                textField -edit -enable 1 -text $directoryName MP_CustomOutputPathTF;
        break;
    }
}
///////////////////////////////////////////////////////////////
// Process: MP_BrowseForFile                                 //
// Browses for a file                                        //
///////////////////////////////////////////////////////////////
global proc string[] MP_BrowseForFile(int $fileMode, string $caption, string $startingDirectory, string $fileFilter)
{
        /* fileMode option
            Indicate what the dialog is to return.
            0 Any file, whether it exists or not.
            1 A single existing file.
            2 The name of a directory. Both directories and files are displayed in the dialog.
            3 The name of a directory. Only directories are displayed in the dialog.
            4 Then names of one or more existing files.
        */
    
        //Uses variable settings passed from MP_BrowseForFilePreProcess, or directly from other processes
        //  to setup the specific data sent to the fileDialog2 box function.
        //Returns selected file(s) as a string array
    string $selectedFiles[] = `fileDialog2 -fileMode $fileMode
                                    -caption $caption
                                    -startingDirectory $startingDirectory
                                    -okCaption "Select"
                                    -cancelCaption "Cancel"
                                    -fileFilter $fileFilter
                                    -dialogStyle 2`;
        
    
    return $selectedFiles;
}
///////////////////////////////////////////////////////////
// Process: MP_GetEggFile2Bam                            //
// User chooses an egg file to perform egg2bam on        //
///////////////////////////////////////////////////////////
global proc MP_GetEggFile2Bam()
{
        /* fileMode option
            Indicate what the dialog is to return.
            0 Any file, whether it exists or not.
            1 A single existing file.
            2 The name of a directory. Both directories and files are displayed in the dialog.
            3 The name of a directory. Only directories are displayed in the dialog.
            4 Then names of one or more existing files.
        */
    
    int $fileMode = 4;
    string $caption = "Select a Panda Egg file to compile to a Panda Bam file...";
    string $startingDirectory = dirname(`file -q -sn`);
    string $fileFilter = "Panda Egg (*.egg)";
    string $pandaFile[] = MP_BrowseForFile($fileMode, $caption, $startingDirectory, $fileFilter);
    
        //Process files selected
    if(size($pandaFile) > 0){
        for($i=0;$i<size($pandaFile);$i++){
            MP_Export2Bam($pandaFile[$i], 1);
        }
    }else{
        error("No file selected!\n");
    }
}
///////////////////////////////////////////////////////////
// Process: MP_GetMayaFile2Egg                           //
// User chooses a Maya 'mb' file to perform maya2egg on  //
///////////////////////////////////////////////////////////
global proc MP_GetMayaFile2Egg()
{
    /*
        Convert one or more Maya binary files into Panda Egg files
    
      fileMode option
        Indicate what the dialog is to return.
        0 Any file, whether it exists or not.
        1 A single existing file.
        2 The name of a directory. Both directories and files are displayed in the dialog.
        3 The name of a directory. Only directories are displayed in the dialog.
        4 Then names of one or more existing files.
    */
    
    int $fileMode = 4;
    string $caption = "Select Maya Binary file(s) to compile into a Panda Egg file...";
    string $startingDirectory = dirname(`file -q -sn`);
    string $fileFilter = "Maya Binary (*.mb)";
    string $mayaFiles[] = MP_BrowseForFile($fileMode, $caption, $startingDirectory, $fileFilter);
    
    if(size($mayaFiles) > 0){
        for($i=0;$i<size($mayaFiles);$i++){
            MP_ExportPrep($mayaFiles[$i], basenameEx($mayaFiles[$i]));
        }
    }else{
        error("No file(s) selected!\n");
    }
}
///////////////////////////////////////////////////////////
// Process: MP_GetBamFile2Egg                            //
// User chooses bam files to convert them to egg files   //
///////////////////////////////////////////////////////////
global proc MP_GetBamFile2Egg()
{
    /* fileMode option
        Indicate what the dialog is to return.
        0 Any file, whether it exists or not.
        1 A single existing file.
        2 The name of a directory. Both directories and files are displayed in the dialog.
        3 The name of a directory. Only directories are displayed in the dialog.
        4 Then names of one or more existing files.
    */
    
    int $fileMode = 4;
    string $caption = "Select a Panda Bam to decompile to an Egg file...";
    string $startingDirectory = dirname(`file -q -sn`);
    string $fileFilter = "Panda Bam (*.bam)";
    string $pandaFile[] = MP_BrowseForFile($fileMode, $caption, $startingDirectory, $fileFilter);
    
    if(size($pandaFile) > 0){
        for($i=0;$i<size($pandaFile);$i++){
            MP_Bam2Egg($pandaFile[$i]);
        }
    }else{
        error("No file(s) selected!\n");
    }
}
///////////////////////////////////////////////////////////
// Process: MP_GetFile2Pview                             //
// User chooses a egg file to send to pview              //
///////////////////////////////////////////////////////////
global proc MP_GetFile2Pview()
{
        /* fileMode option
            Indicate what the dialog is to return.
            0 Any file, whether it exists or not.
            1 A single existing file.
            2 The name of a directory. Both directories and files are displayed in the dialog.
            3 The name of a directory. Only directories are displayed in the dialog.
            4 Then names of one or more existing files.
        */
    
    string $pviewExecutable = MP_PandaVersion("getPview");
    string $startingDirectory = dirname(`file -q -sn`);
    int $fileMode = 1;
    string $caption = "Select Panda file to Pview...";
    string $fileFilter = ("Panda Egg (*.egg);;Panda Bam (*.bam)");
    string $pviewFile[] = MP_BrowseForFile($fileMode, $caption, $startingDirectory, $fileFilter);
    
        //Send the file to pview process
    if(size($pviewFile) == 1){
        MP_Send2Pview($pviewFile[0]);
    }else{
        error("No file selected!\n");
    }
}
///////////////////////////////////////////////////////////////
// Process: MP_BrowseForFolderPreProcess                     //
// Pass specific variables to MP_BrowseForFolder             //
///////////////////////////////////////////////////////////////
global proc MP_BrowseForFolderPreProcess(string $option)
{
    /*
        Indicate what the dialog is to return.
        0 Any file, whether it exists or not.
        1 A single existing file.
        2 The name of a directory. Both directories and files are displayed in the dialog.
        3 The name of a directory. Only directories are displayed in the dialog.
        4 The names of one or more existing files.
    */
    
    string $outputPandaFileType = `radioCollection -query -select MP_OutputPandaFileTypeRC`;
    
    switch($option){
        case "customRelativeEggTexturePath":
            int $fileMode = 3;
            string $caption = "Choose Texture Relative Directory For Egg File";
            string $folderPath = MP_BrowseForFolder($fileMode, $caption);
            textField -edit -enable 1 -text $folderPath MP_CustomEggTexPathTF;
            
                //If exporting both file type, use same data for Bam file Texture referencing as default
            if($outputPandaFileType == "MP_ChooseEggBamRB"){
                textField -edit -enable 1 -text $folderPath MP_CustomBamTexPathTF;
            }
        break;
        case "customRelativeBamTexturePath":
            int $fileMode = 3;
            string $caption = "Choose Texture Relative Directory For Bam File";
            string $folderPath = MP_BrowseForFolder($fileMode, $caption);
            textField -edit -enable 1 -text $folderPath MP_CustomBamTexPathTF;
        break;
        case "customOutputPath":
            int $fileMode = 3;
            string $caption = "Choose Custom Output Folder";
            string $folderPath = MP_BrowseForFolder($fileMode, $caption);
            radioButton -edit -select MP_ChooseCustomOutputPathRB;
            button -edit -enable 1 MP_BrowseOutputPathBTN;
            textField -edit -enable 1 -text $folderPath MP_CustomOutputPathTF;
        break;
    }
}
///////////////////////////////////////////////////////////////
// Process: MP_BrowseForFolder                               //
// Browses for a folder                                      //
///////////////////////////////////////////////////////////////
global proc string MP_BrowseForFolder(int $fileMode, string $caption)
{
    /*
        Uses variable settings passed from MP_BrowseForFolderPreProcess
        to setup the specific data in the fileDialog2 box
        Returns selected folder as a string
    */
    
    string $result[] = `fileDialog2 -fileMode $fileMode -caption $caption -okCaption "Select" -ds 2`;
    return $result[0];
}
///////////////////////////////////////////////////////////////
// Process: Set Object-Type Button Annotation                //
// Returns the button annotation for passed object type      //
///////////////////////////////////////////////////////////////
global proc string MP_GetObjectTypeAnnotation(string $objectType)
{
    /*
        Returns the egg-object-type button annotation text of defined types as a string for GUI.
    */
    
    string $annotation = "";
    switch($objectType)
    {
        case "barrier":
            $annotation = ("<Collide> { Polyset descend }"
                            +"\n\nCreates a barrier that other objects cannot pass through."
                            +"\nThe collision is active on the \"Normals\" side of the object(s)");
        break;
        
        case "floor":
            $annotation = ("Creates a collision from the object(s) that \"Avatars\" can walk on."
                            +"\nIf the surface is angled, the Avatar will not slide down it."
                            +"\nThe collision is active on the \"Normals\" side of the object(s)");
        break;
		
		case "shadow-cast":
		    $annotation = ("<Tag> cam { shground }"
                            +"\n<Scalar> draw-order { 0 }"
                            +"\n<Scalar> bin { ground }"
			                +"\n\nGives the selected object(s) the required attributes so that an"
			                +"\n\"Avatar's\" shadow can be cast over it. Commonly used for casting"
							+"\nan \"Avatar's\" shadow onto floors.");
		break;
        
        case "dupefloor":
            $annotation = ("<Collide> { Polyset keep descend level }"
                            +"\n\nThis type first creates a duplicate of the selected object(s)."
                            +"\nThen, creates a floor collision from the duplicate object(s) that \"Avatars\" can walk on."
                            +"\nIf the surface is angled, the Avatar will not slide down it."
                            +"\nThe collision is active on the \"Normals\" side of the object(s)");
        break;
		
		case "smooth-floors":
		    $annotation = ("<Collide> { Polyset descend }"
			                +"\n<Scalar> from-collide-mask { 0x000fffff }"
                            +"\n<Scalar> into-collide-mask { 0x00000002 }"
						    +"\n\nMakes floors smooth for the \"Avatars\" to walk and stand on.");
		break;
						  
        
        case "sphere":
            $annotation = ("<Collide> { Sphere descend }"
                            +"\n\nCreates a \"minimum-sized\" sphere collision around the selected object(s),"
                            +"\nthat other objects cannot enter into.");
        break;
        
        case "tube":
            $annotation = ("<Collide> { Tube descend }"
                            +"\n\nCreates a \"minimum-sized\" tube collision around the selected object(s),"
                            +"\nthat other objects cannot enter into.");
        break;
        
        case "trigger":
            $annotation = ("<Collide> { Polyset descend intangible }"
                            +"\n\nCreates a collision that can be used as a \"Trigger\","
                            +"\nwhich can be used to activate, or deactivate, specific processes."
                            +"\nThe collision is active on the \"Normals\" side of the object(s)");
        break;
        
        case "trigger-sphere":
            $annotation = ("<Collide> { Sphere descend intangible }"
                            +"\n\nCreates a \"minimum-sized\" sphere collision that can be used as a \"Trigger\","
                            +"\nwhich can be used to activate, or deactivate, specific processes"
                            +"\nThe collision is active on the \"Normals\" side of the object(s)");
        break;
        
        case "invsphere":
            $annotation = ("<Collide> { InvSphere descend }"
                            +"\n\nCreates a \"minimum-sized\" inverse-sphere collision around the selected object(s)."
                            +"\nAny object inside the sphere will be prevented from exiting the sphere.");
        break;
        
        case "bubble":
            $annotation = ("<Collide> { Sphere keep descend }"
                            +"\n\n\"bubble\" puts a Sphere collision around the geometry,"
                            +"\nbut does not otherwise remove the geometry.");
        break;
        
        case "polylight":
            $annotation = ("<Scalar> polylight { 1 }");
        break;
        
        case "portal":
            $annotation = ("<Scalar> portal { 1 }"
                            +"\n\nUsed on a rectangular polygon to set it as a \"PortalNode\"."
                            +"\nThis portal is used by the camera to \"see through\" to other cells."
                            +"\nMeaning, when the camera is looking through the portal,"
                            +"\nthe cell on the other side of the portal window is made visible"
                            +"\nThis visiblilty is to be all computed via the python code."
                            +"\nThe basic idea is that you divide your scene up into \"cells\","
                            +"\nwhich are just toplevel nodes under render."
                            +"\nEverything that is in cell A should be grouped together under node A."
                            +"\nThen you parent all cell nodes to render, and hide them all."
                            +"\nThen you create a bunch of PortalNodes."
                            +"\nEach PortalNode is a window from one cell to another."
                            +"\nThe PortalNode itself contains the geometry of the window."
                            +"\nParent the PortalNode within the cell that you are looking from,"
                            +"\nand call node.setCellIn() and node.setCellOut() to tell it the NodePaths"
                            +"\nof the \"in\" cell (the current cell) and the \"out\" cell"
                            +"\n(the cell you are looking at), respectively.");
        break;
        
        case "dual":
            $annotation = ("<Scalar> alpha { dual }"
                            +"\n\nNormally attached to polygons that have transparency,"
                            +"\nthat are in the scene by themselves."
                            +"\nSuch as a Tree, or Flower.");
        break;
        
        case "ghost":
            $annotation = ("<Scalar> collide-mask { 0 }"
                            +"\n\n\"ghost\" turns off the normal collide bit that is set on visible"
                            +"\ngeometry by default, so that if you are using visible geometry for"
                            +"\ncollisions, this particular geometry will not be part of those"
                            +"\ncollisions--it is ghostlike."
                            +"\nIt means that the geometry beginning at this node and below"
                            +"\nshould never be collided with--characters will pass through it.");
        break;
        
        case "glass":
            $annotation = ("<Scalar> alpha { blend_no_occlude }");
        break;
        
        case "glow":
            $annotation = ("<Scalar> blend { add }"
                            +"\n\n\"glow\" is useful for halo effects and things of that ilk."
                            +"\nIt renders the object in add mode instead of the normal opaque mode.");
        break;
        
        case "binary":
            $annotation = ("<Scalar> alpha { binary }"
                            +"\nThis mode of alpha sets transparency pixels"
                            +"\nto either on, or off. No blending is used.");
        break;
        
        case "indexed":
            $annotation = ("<Scalar> indexed { 1 }");
        break;
        
        case "model":
            $annotation = ("<Model> { 1 }"
                            +"\n\nThis creates a ModelNode at the corresponding level"
                            +"\nwhich is guaranteed not to be removed by any flatten operation."
                            +"\nHowever, its transform might still be changed");
        break;
        
        case "dcs":
            $annotation = ("<DCS> { 1 }"
                            +"\n\nIndicates the node should not be flattened out of the hierarchy during conversion."
                            +"\nAlso indicates that the node's transform is important and should be preserved."
                            +"\nHowever, nodes under the node \"might be flattened out\".");
        break;
        
        case "notouch":
            $annotation = ("<DCS> { no_touch }"
                            +"\n\nIndicates the node, and below, should not be flattened"
                            +"\nout of the hierarchy during the conversion process.");
        break;
        
        case "double-sided":
            $annotation = ("<BFace> { 1 }"
                            +"\n\nThis defines whether the polygon will be rendered double-sided"
                            +"\n(i.e. its back face will be visible)."
                            +"\n\nThis is a builtin type of Panda and no PRC setting is required");
        break;
        
        case "billboard":
            $annotation = ("<Billboard> { axis }"
                            +"\n\nRotates the geometry to always face the camera."
                            +"\nGeometry will rotate on its local axis."
                            +"\n\nThis is a builtin type of Panda and no PRC setting is required");
        break;
        
        case "seq2":
            $annotation = ("<Switch> { 1 }"
                            +"\n<Scalar>  fps { 2 }"
                            +"\n\nThe <Switch> { 1 } indicates that the child nodes of this group represent"
                            +"\na series of animation frames that should be consecutively displayed."
                            +"\nThe <Scalar> fps { 2 } indicates rate of animation for the SequenceNode."
                            +"\nA value of zero indicates only a SwitchNode should be created instead."
                            +"\nand it the responsibility of the show code to perform the switching.");
        break;
        
        case "seq4":
            $annotation = ("<Switch> { 1 }"
                            +"\n<Scalar>  fps { 4 }"
                            +"\n\nThe <Switch> { 1 } indicates that the child nodes of this group represent"
                            +"\na series of animation frames that should be consecutively displayed."
                            +"\nThe <Scalar> fps { 4 } indicates rate of animation for the SequenceNode."
                            +"\nA value of zero indicates only a SwitchNode should be created instead."
                            +"\nand it the responsibility of the show code to perform the switching.");
        break;
        
        case "seq6":
            $annotation = ("<Switch> { 1 }"
                            +"\n<Scalar>  fps { 6 }"
                            +"\n\nThe <Switch> { 1 } indicates that the child nodes of this group represent"
                            +"\na series of animation frames that should be consecutively displayed."
                            +"\nThe <Scalar> fps { 6 } indicates rate of animation for the SequenceNode."
                            +"\nA value of zero indicates only a SwitchNode should be created instead."
                            +"\nand it the responsibility of the show code to perform the switching.");
        break;
        
        case "seq8":
            $annotation = ("<Switch> { 1 }"
                            +"\n<Scalar>  fps { 8 }"
                            +"\n\nThe <Switch> { 1 } indicates that the child nodes of this group represent"
                            +"\na series of animation frames that should be consecutively displayed."
                            +"\nThe <Scalar> fps { 8 } indicates rate of animation for the SequenceNode."
                            +"\nA value of zero indicates only a SwitchNode should be created instead."
                            +"\nand it the responsibility of the show code to perform the switching.");
        break;
        
        case "seq10":
            $annotation = ("<Switch> { 1 }"
                            +"\n<Scalar>  fps { 10 }"
                            +"\n\nThe <Switch> { 1 } indicates that the child nodes of this group represent"
                            +"\na series of animation frames that should be consecutively displayed."
                            +"\nThe <Scalar> fps { 10 } indicates rate of animation for the SequenceNode."
                            +"\nA value of zero indicates only a SwitchNode should be created instead."
                            +"\nand it the responsibility of the show code to perform the switching.");
        break;
        
        case "seq12":
            $annotation = ("<Switch> { 1 }"
                            +"\n<Scalar>  fps { 12 }"
                            +"\n\nThe <Switch> { 1 } indicates that the child nodes of this group represent"
                            +"\na series of animation frames that should be consecutively displayed."
                            +"\nThe <Scalar> fps { 12 } indicates rate of animation for the SequenceNode."
                            +"\nA value of zero indicates only a SwitchNode should be created instead."
                            +"\nand it the responsibility of the show code to perform the switching.");
        break;
        
        case "seq24":
            $annotation = ("<Switch> { 1 }"
                            +"\n<Scalar>  fps { 24 }"
                            +"\n\nThe <Switch> { 1 } indicates that the child nodes of this group represent"
                            +"\na series of animation frames that should be consecutively displayed."
                            +"\nThe <Scalar> fps { 24 } indicates rate of animation for the SequenceNode."
                            +"\nA value of zero indicates only a SwitchNode should be created instead."
                            +"\nand it the responsibility of the show code to perform the switching.");
        break;
        
        default:
                $annotation = ("Adds the " + $objectType + " egg-object-type to selected geometry.");
        break;
    }
    
        //Return the string
    return $annotation;
}
///////////////////////////////////////////////////////////
// Imports a Panda bam or egg file.                      //
///////////////////////////////////////////////////////////
global proc MP_ImportPandaFile()
{
    /*
      PROCESS OPERATIONS:
        If selected file is a BAM File:
            If $gMP_PhaseRootDir variable is empty, prompt user to select the folder
            Copies selected bamfile to phase root folder
            Performs bam2egg on the file.
            Imports the created egg file into the scene.
            Deletes the copied file from phase root,
        If selected file is an EGG File:
            Imports the egg file into current scene
        
        fileMode options
            Indicate what the dialog is to return.
            0 Any file, whether it exists or not.
            1 A single existing file.
            2 The name of a directory. Both directories and files are displayed in the dialog.
            3 The name of a directory. Only directories are displayed in the dialog.
            4 Then names of one or more existing files.
    */
    
        //Process Variables
    global string $gMP_PhaseRootDir[];
    global string $gMP_MayaVersionShort;
    global int $gMP_ChoosePandaFileNotice;
    int $exists = 0;
    
        //Verify we have the egg importer plugin loaded
        //If it is not, we assume it is not installed,
        //so, we notify user and ask them to download the Panda3D-SDK
    if(`pluginInfo -query -loaded -name ("mayaeggimport" + $gMP_MayaVersionShort)` == 0){
		string $pluginLoadedConfirm = MP_ConfirmationDialog("mayaeggimport" + $gMP_MayaVersionShort + " Plugin ERROR!"
                                                            , "Panda Egg Import plugin is either not currently loaded,"
                                                                + "\nor not currently installed."
                                                                + "\nIf you do not have the Panda3D SDK egg importer installed,"
                                                                + "\nWould you like to download the Panda3D SDK now?"
                                                            , "downloadcancel");
                                    
        if($pluginLoadedConfirm == "DOWNLOAD"){
            MP_GotoPanda3DSDKDownload();
        }
    }else{
            //Check if the $gMP_PhaseRootDir folder has been previously chosen
            //If not, we need to ask for the phase root directory so bam2egg can find the textures
        if($gMP_PhaseRootDir[0] == ""){
                //Prompt user to select the Phase ROOT folder
            string $choosePhaseRoot = MP_ConfirmationDialog("Phase Root Folder Selection"
                                                            , "In the following dialog box, select the directory"
                                                                + "\nin which your extracted phase folders are located."
                                                                + "\n\nI.E. your phase root folder."
                                                                + "\n\nPress \"Select\" to continue, press \"Cancel\" to exit."
                                                            , "selectcancel");
            
            if($choosePhaseRoot == "SELECT"){
                $gMP_PhaseRootDir = `fileDialog2 -fileMode 3 -dialogStyle 2 -caption "Select Phase Root Directory" -okCaption "Select"`;
            }
        }
        
            //Proceed if phase root directory has been selected
        if($gMP_PhaseRootDir[0] != ""){
                //Show importing notification message if the user has not seen it yet this session.
            if($gMP_ChoosePandaFileNotice == 0){
                string $choosePandaFile = MP_ConfirmationDialog("Panda File Selection"
                                                                , "In the following dialog box, select the Panda File(s) you wish to import."
                                                                    + "\n\nThis can be Panda bam or Panda Egg file(s)."
                                                                    + "\n\nPress \"Select\" to choose the Panda file(s)"
                                                                    + "\nPress \"Cancel\" to exit this process."
                                                                    + "\n\nThis is the only time you will see this message this Maya session."
                                                                , "selectcancel");
                
                if(($choosePandaFile == "SELECT") && ($gMP_PhaseRootDir[0] != "")){
                        //Since user is continuing and has now seen the importing notification,
                        //we register this in the global variable so future imports in the same session will be skipped.
                    $gMP_ChoosePandaFileNotice = 1;
                }
            }
            
            if($gMP_ChoosePandaFileNotice == 1){
                    //Select Panda file(s) to import
                int $fileMode = 4;
                string $caption = "Select Panda Egg or Panda Bam file to import.";
                string $startingDirectory = dirname(`file -q -sn`);
                string $fileFilter = "Panda bam file (*.bam);;Panda egg file (*.egg)";
                string $pandaFile[] = MP_BrowseForFile($fileMode, $caption, $startingDirectory, $fileFilter);
                    
                    //Verify we have selected at least one file to import into scene
                if((size($pandaFile) > 0) && ($gMP_PhaseRootDir[0] != "")){
                    for($i=0;$i<size($pandaFile);$i++){
                            //populate the variables
                        string $filePath = dirname($pandaFile[$i]);
                        string $baseFileName = basenameEx($pandaFile[$i]);
                        string $fileExtension = fileExtension($pandaFile[$i]);
                            
                            //Verify we have information in all the variables
                        if(($filePath == "") || ($baseFileName == "") || ($fileExtension == "")){
                                //Cannot operate without a Panda file. Throw a message if it appears one has not been selected.
                            MP_ConfirmationDialog("No File Selected"
                                                    , "No Panda File is currently selected"
                                                    , "ok");
                        }else{   
                                //if selected file is a Panda BAM file, process here
                            if($fileExtension == "bam"){
                                    //If the selected file path does not start with the phaseRoot,
                                    //it means we are probably trying to import a Panda file from a [different] set of phases
                                    //So, we need to query user to choose the proper $gMP_PhaseRootDir phase file root folder.
                                if(startsWith($filePath, $gMP_PhaseRootDir[0]) == 0){
                                        //Prompt user to select the Phase folder ROOT folder
                                    string $choosePhaseRoot = MP_ConfirmationDialog("Phase Root Folder Different"
                                                                                    , "You appear to be importing a Panda file with a different phase root location."
                                                                                        + "\nPlease select the appropriate Phase Root Folder for this file."
                                                                                        + "\n\nI.E. the root folder that all the Phase_* folders are in."
                                                                                        + "\n\nPress \"Select\" to continue, press \"Cancel\" to exit."
                                                                                    , "selectcancel");
                                    
                                    if($choosePhaseRoot == "SELECT"){
                                        $gMP_PhaseRootDir = `fileDialog2 -fileMode 3 -dialogStyle 2 -caption "Select Phase Root Directory" -okCaption "Select"`;
                                    }
                                }
                                        
                                if($gMP_PhaseRootDir[0] != ""){
                                            //Define bam file name full path.
                                    string $bamFile = ($gMP_PhaseRootDir[0] + "/" + $baseFileName + ".bam");
                                        
                                        //Define egg file name full path.
                                    string $eggFile = ($gMP_PhaseRootDir[0] + "/" + $baseFileName + ".egg");
                                      
                                        //Check to see if the selected Bam file originated from the Phase Root Folder.
                                        //We do this by comparing full file paths of selected file and generated $bamFile file path.
                                        //If it did, then we skip BOTH, the copy process and the source bam file deleting process.
                                        //  This is done as a safeguard since the file was obviously in the root for a purpose
                                        //    and we don't want to inadvertently delete the only Bam File copy the user may have.
                                    if($bamFile != $pandaFile[$i]){
                                            //Since source file isn't in the set phase root folder already,
                                            //  we first copy the selected source bam file to phase root, then convert it to an egg file.
                                            //This is done so the textures will be found,
                                            //  based on the standard of Disney Bam file texture referencing from the root.
                                        sysFile -copy $bamFile $pandaFile[$i];
                                    }

                                        //Convert the bam file to an egg file (which will use the currently selected bam version)
                                    MP_Bam2Egg($bamFile);
                                    
                                        //We loop to check for when the egg file has been created and appears in the folder.
                                        //Once it has been converted and appears, we can proceed with file importing.
                                        //We also will exit if a loopCount has reached the specified amount.
                                        //  This is incase there is a conversion error and egg file is not created,
                                        //      we don't want the script to hang up.
                                    int $loopCount = 0;
                                    int $eggError = 0;
                                    
                                    do{
                                            //Check if egg file has been created each loop cycle
                                        if(`file -query -exists $eggFile` == 1){
                                                //File exists now, so we import it into the scene
                                            print ("Importing Panda File: " + $eggFile + "\n");
                                            file -import $eggFile;
                                                
                                                //If the selected original Bam file did NOT originate from the Phase Root Folder,
                                                //  we delete the bam file from the phase root folder, since it is only a copy that we have made.
                                            if($bamFile != $pandaFile[$i]){
                                                sysFile -delete $bamFile;
                                            }
                                                //Set variable to exit loop
                                            $exists = 1;
                                        }else{
                                                //increment loop count (loops every 5 seconds)
                                                //We exit this loop if a full minute has passed and file hasn't been created by then.
                                                //12 loops *5 seconds/loop = 60 seconds
                                            $loopCount++;
                                                //Add a 5 second pause between checking for file
                                            pause -seconds 5;
                                        }
                                    }
                                    while (($exists == 0) && ($loopCount < 11));
                                }
                            }
                            
                                //if selected file is a Panda EGG file, process here
                                //We do not really care if the egg file is not in the phase root,
                                //  since its texture paths are probably already correct from where it is located,
                                //  and will be able to find the textures.
                            if($fileExtension == "egg"){
                                if(`file -query -exists $pandaFile[$i]` == 1){
                                    print ("Importing Panda Egg: " + $baseFileName + ".egg\n");
                                    file -import $pandaFile[$i];
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
///////////////////////////////////////////////////////////
// Process: MP_Send2Pview                                //
// Used by export script to send file to pview if chosen //
///////////////////////////////////////////////////////////
global proc MP_Send2Pview(string $file)
{
        /*
            If a file is passed to this process, it will call the pview
            version that is defined in the gMP_PandaFileVersions array,
            and run that pview against the chosen file.
            
            If $file is empty, the process will call pview inside of Maya,
            which then uses the plugin version libmayapview[version]
            and sends the full scene, or selected nodes, to the pview process.
        */
        //Process Variables
    global string $gMP_MayaVersionShort;
    
        //Check if a file was passed to this process
        //If not, we will run pview plugin the scene itself
    if($file == ""){
            //Check for loaded pview plugins
        if(`pluginInfo -query -loaded -name ("libmayapview" + $gMP_MayaVersionShort)` == 1){
                //Check for selection type. Will be either all, or selected
            if(`checkBox -query -value MP_ExportSelectedCB` == 1){
                print "\nStarting pview ... \n";
                pview;
                print("End pview\n");
            }else{
                select -clear;
                print "\nStarting pview ... \n";
                pview;
                print("End pview\n");
            }
        }
        
        if(`pluginInfo -query -loaded -name ("libmayasavepview" + $gMP_MayaVersionShort)` == 1){
                //Seems this plugin requires a scene to have been saved, i.e. has a scene name first
                //It does not view against current scene, so lets prompt user to choose a file
                //Then run pview against the chosen file.
            MP_GetFile2Pview();
        }
    }else{
        string $pviewExecutable = MP_PandaVersion("getPview");
        print "\nStarting pview ... \n";
        print $file;
        print "\n";
        
        string $result =
        system(
            $pviewExecutable + " -l -c "
            + "\"" + $file + "\""
        );
        print ($result + "\n");
        print("End pview\n");
    }
}
///////////////////////////////////////////////////////////
// Process: Export Lights Selected                       //
///////////////////////////////////////////////////////////
global proc MP_LightsSelectedUI()
{
    int $value = `checkBox -query -value MP_ExportLightsCB`;
  
    switch($value){
        case 0:
            //
        break;
        case 1:
            print("Light Nodes will be converted to locators.\n");
        break;
    }
}
///////////////////////////////////////////////////////////
// Process: Export Cameras Selected                      //
///////////////////////////////////////////////////////////
global proc MP_CamerasSelectedUI()
{
    int $value = `checkBox -query -value MP_ExportCamerasCB`;
  
    switch($value){
        case 0:
            //
        break;
        case 1:
            print("Cameras will be converted to locators.\n");
        break;
    }
}
///////////////////////////////////////////////////////////
// Process: Export Cameras Selected                      //
///////////////////////////////////////////////////////////
global proc MP_RemoveGroundPlaneUI()
{
    /*
        This currently only removes the groundPlane_transform entry from Mesh exports.
        If any other export option is chosen, the tuple will be written to the egg file.
    */
    
    int $value = `checkBox -query -value MP_RemoveGroundPlaneCB`;
  
    switch($value){
        case 0:
            //
        break;
        case 1:
            print("The \"groundPlane_transform\" node will be excluded from the exported file(s)\n");
        break;
        
    }
}
///////////////////////////////////////////////////////////
// Process: MP_ExportOptionsUI                           //
// Updates the UI when a radio button is chosen          //
///////////////////////////////////////////////////////////
global proc MP_ExportOptionsUI()
{
    string $selectedRB = `radioCollection -query -select MP_ExportOptionsRC`;
    
    switch($selectedRB)
    {
        case "MP_ChooseActorRB":
                print("Export as animated Actor\n");
                intField -edit -enable 0 -value 0 MP_AnimationStartFrameIF;
                intScrollBar -edit -enable 0 -value 0 MP_AnimationStartFrameSlider;
                intField -edit -enable 0 -value 48 MP_AnimationEndFrameIF;
                intScrollBar -edit -enable 0 -value 48 MP_AnimationEndFrameSlider;
                radioButton -edit -enable 0 -select MP_chooseFullAnimationRangeRB;
                radioButton -edit -enable 0 MP_chooseCustomAnimationRangeRB;
                text -edit -enable 1 MP_CharacterNameLabel;
                textField -edit -enable 1 MP_CharacterNameTF;
                text -edit -enable 1 MP_ForceJointLabel;
                textField -edit -enable 1 MP_ForceJointTF;
                radioButton -edit -select MP_ChooseTransformModelRB;
                checkBox -edit -enable 0 -value 0 MP_ExportLightsCB;
                checkBox -edit -enable 0 -value 0 MP_ExportCamerasCB;
                checkBox -edit -enable 0 -value 0 MP_RemoveGroundPlaneCB;
                MP_AnimationOptionsUI("animationMode","");
                MP_AnimationOptionsUI("updateFrameValues","updateAllValues");
        break;
        case "MP_ChooseAnimationRB":
                print("Export Current Actor Animation\n");
                intField -edit -enable 0 -value 0 MP_AnimationStartFrameIF;
                intScrollBar -edit -enable 0 -value 0 MP_AnimationStartFrameSlider;
                intField -edit -enable 0 -value 48 MP_AnimationEndFrameIF;
                intScrollBar -edit -enable 0 -value 48 MP_AnimationEndFrameSlider;
                radioButton -edit -enable 1 -select MP_chooseFullAnimationRangeRB;
                radioButton -edit -enable 1 MP_chooseCustomAnimationRangeRB;
                text -edit -enable 1 MP_CharacterNameLabel;
                textField -edit -enable 1 MP_CharacterNameTF;
                text -edit -enable 1 MP_ForceJointLabel;
                textField -edit -enable 1 MP_ForceJointTF;
                radioButton -edit -select MP_ChooseTransformModelRB;
                checkBox -edit -enable 0 -value 0 MP_ExportLightsCB;
                checkBox -edit -enable 0 -value 0 MP_ExportCamerasCB;
                checkBox -edit -enable 0 -value 0 MP_RemoveGroundPlaneCB;
                MP_AnimationOptionsUI("animationMode","");
                MP_AnimationOptionsUI("updateFrameValues","updateAllValues");
        break;
        case "MP_ChooseBothRB":
                print("Export Meshes and Animation\n");
                intField -edit -enable 0 -value 0 MP_AnimationStartFrameIF;
                intScrollBar -edit -enable 0 -value 0 MP_AnimationStartFrameSlider;
                intField -edit -enable 0 -value 48 MP_AnimationEndFrameIF;
                intScrollBar -edit -enable 0 -value 48 MP_AnimationEndFrameSlider;
                radioButton -edit -enable 1 -select MP_chooseFullAnimationRangeRB;
                radioButton -edit -enable 1 MP_chooseCustomAnimationRangeRB;
                text -edit -enable 1 MP_CharacterNameLabel;
                textField -edit -enable 1 MP_CharacterNameTF;
                text -edit -enable 1 MP_ForceJointLabel;
                textField -edit -enable 1 MP_ForceJointTF;
                radioButton -edit -select MP_ChooseTransformModelRB;
                checkBox -edit -enable 0 -value 0 MP_ExportLightsCB;
                checkBox -edit -enable 0 -value 0 MP_ExportCamerasCB;
                checkBox -edit -enable 0 -value 0 MP_RemoveGroundPlaneCB;
                MP_AnimationOptionsUI("animationMode","");
                MP_AnimationOptionsUI("updateFrameValues","updateAllValues");
        break;
        case "MP_ChooseMeshRB":
                print("Export as Mesh\n");
                intField -edit -enable 0 MP_AnimationStartFrameIF;
                intScrollBar -edit -enable 0 MP_AnimationStartFrameSlider;
                intField -edit -enable 0 MP_AnimationEndFrameIF;
                intScrollBar -edit -enable 0 MP_AnimationEndFrameSlider;
                radioButton -edit -enable 0 -select MP_chooseFullAnimationRangeRB;
                radioButton -edit -enable 0 MP_chooseCustomAnimationRangeRB;
                text -edit -enable 0 MP_CharacterNameLabel;
                textField -edit -enable 0 -text "" MP_CharacterNameTF;
                text -edit -enable 0 MP_ForceJointLabel;
                textField -edit -enable 0 -text "" MP_ForceJointTF;
                radioButton -edit -select MP_ChooseTransformModelRB;
                checkBox -edit -enable 1 MP_ExportLightsCB;
                checkBox -edit -enable 1 MP_ExportCamerasCB;
                checkBox -edit -enable 1 -value 1 MP_RemoveGroundPlaneCB;
                MP_AnimationOptionsUI("animationMode","");
                MP_AnimationOptionsUI("updateFrameValues","updateAllValues");
        break;
        case "MP_ChoosePoseRB":
                print("Export Selected Actor Animation Pose\n");
                intField -edit -enable 1 -value 0 MP_AnimationStartFrameIF;
                intScrollBar -edit -enable 1 -value 0 MP_AnimationStartFrameSlider;
                intField -edit -enable 0 -value 48 MP_AnimationEndFrameIF;
                intScrollBar -edit -enable 0 -value 48 MP_AnimationEndFrameSlider;
                radioButton -edit -enable 0 MP_chooseFullAnimationRangeRB;
                radioButton -edit -enable 1 -select MP_chooseCustomAnimationRangeRB;
                text -edit -enable 1 MP_CharacterNameLabel;
                textField -edit -enable 1 MP_CharacterNameTF;
                text -edit -enable 1 MP_ForceJointLabel;
                textField -edit -enable 1 MP_ForceJointTF;
                radioButton -edit -select MP_ChooseTransformModelRB;
                checkBox -edit -enable 0 -value 0 MP_ExportLightsCB;
                checkBox -edit -enable 0 -value 0 MP_ExportCamerasCB;
                checkBox -edit -enable 0 -value 0 MP_RemoveGroundPlaneCB;
                MP_AnimationOptionsUI("animationMode","");
                MP_AnimationOptionsUI("updateFrameValues","updateAllValues");
        break;
    }
}
///////////////////////////////////////////////////////////
// Process: MP_AnimationOptionsUI                        //
// Updates the UI when a radio button is chosen          //
///////////////////////////////////////////////////////////
global proc MP_AnimationOptionsUI(string $option, string $toUpdate)
{
    /*
        Updates the Animation scroll bar and integer fields based on selection
    */
    
    switch($option)
    {
        case "animationMode":
                string $selectedRB = `radioCollection -query -select MP_AnimationOptionsRC`;
                switch($selectedRB)
                {
                    case "MP_chooseFullAnimationRangeRB":
                            print("Exporting Full Animation Range\n");
                            intField -edit -enable 0 MP_AnimationStartFrameIF;
                            intScrollBar -edit -enable 0 MP_AnimationStartFrameSlider;
                            intField -edit -enable 0 MP_AnimationEndFrameIF;
                            intScrollBar -edit -enable 0 MP_AnimationEndFrameSlider;
                            text -edit -enable 0 MP_AnimationStartFrameLabel;
                            text -edit -enable 0 MP_AnimationEndFrameLabel;
                            MP_GetSelectedAnimationLayerLengthUI();
                    break;
                    case "MP_chooseCustomAnimationRangeRB":
                            print("Exporting Custom Animation Range\n");
                            intField -edit -enable 1 MP_AnimationStartFrameIF;
                            intScrollBar -edit -enable 1 MP_AnimationStartFrameSlider;
                            intField -edit -enable 1 MP_AnimationEndFrameIF;
                            intScrollBar -edit -enable 1 MP_AnimationEndFrameSlider;
                            text -edit -enable 1 MP_AnimationStartFrameLabel;
                            text -edit -enable 1 MP_AnimationEndFrameLabel;
                            MP_GetSelectedAnimationLayerLengthUI();
                    break;
                }
        break;
        case "updateFrameValues":
                switch($toUpdate)
                {
                        //Update Animation Frame Float Fields and Float Sliders
                    case "startFrameIFChanged":
                            intScrollBar -edit -value (`intField -query -value MP_AnimationStartFrameIF`) MP_AnimationStartFrameSlider;
                    break;
                    case "startFrameSliderMoved":
                            intField -edit -value (`intScrollBar -query -value MP_AnimationStartFrameSlider`) MP_AnimationStartFrameIF;
                    break;
                    case "endFrameIFChanged":
                            intScrollBar -edit -value (`intField -query -value MP_AnimationEndFrameIF`) MP_AnimationEndFrameSlider;
                    break;
                    case "endFrameSliderMoved":
                            intField -edit -value (`intScrollBar -query -value MP_AnimationEndFrameSlider`) MP_AnimationEndFrameIF;
                    break;
                    case "updateAllValues":
                            intScrollBar -edit -value (`intField -query -value MP_AnimationStartFrameIF`) MP_AnimationStartFrameSlider;
                            intField -edit -value (`intScrollBar -query -value MP_AnimationStartFrameSlider`) MP_AnimationStartFrameIF;
                            intScrollBar -edit -value (`intField -query -value MP_AnimationEndFrameIF`) MP_AnimationEndFrameSlider;
                            intField -edit -value (`intScrollBar -query -value MP_AnimationEndFrameSlider`) MP_AnimationEndFrameIF;
                    break;
                }
        break;
    }
}
///////////////////////////////////////////////////////////
// Process: MP_GetSelectedAnimationLayerLengthUI         //
// Process to retreive the actual last key frame         //
// of the currently selected animation layer.            //
///////////////////////////////////////////////////////////
global proc MP_GetSelectedAnimationLayerLengthUI()
{
        /*
            Process which determines the last key frame of the currently selected animation layer
            & updates the 'Start Frame' & 'End Frame' integer fields of the GUI.
            It uses a default of '0' for the start frame & the last key frame as the end frame.
            
            Process Operation:
                Process is called whenever user toggles the 'MP_AnimationOptionsRC' radio buttons.
                It uses the currently selected animation layer. In order to determine the
                last key frame in an animation layer, we first set the animation
                start time to 0 & the animation end time to an [extreme] 10000.
                Then, we must select EVERYTHING in the scene so we know we have the items
                that will be included in the animation layer.
                We then query the selected animation layer for the last key frame that is visible in it.
                We then update the start & end integer fields using 0 for the start,
                and the retrieved last key frame as the animation end frame.
                If we find no kay frames, we default to end time of '48'.
                We lastly set the start & end animation times back to what they originally were.
        */
    
        //Record any currently selected nodes
        //so we can revert the selections after processing
    string $currentSelection[] = `ls -sl`;
        
        //Variable to hold any now selected nodes in the selected animation layer, if any
    string $nodesSelected[];
    clear $nodesSelected;
    
        //Record the current values so we can revert thnm once we finish processing
    int $currentMin = `playbackOptions -query -min`;
    int $currentMax = `playbackOptions -query -max`;
    int $currentStartTime = `playbackOptions -query -animationStartTime`;
    int $currentEndTime = `playbackOptions -query -animationEndTime`;
    
    if(`objExists "BaseAnimation"` == 1){
            //Generate an array conataining all children layers of the default 'BaseAnimation' layers
        string $childLayersList[] = `animLayer -query -children "BaseAnimation"`;
        
            //Check if we have layers other than the default 'BaseAnimation' layer,
            //or if the 'BaseAnimation' layer is the currently selected layer.
        if(size($childLayersList) == 0){
            select -r -all -hi;
        }else{
                //Cycle through each child layer to determine the currently selected layer
            for($item in $childLayersList){
                    //Loop to determine which animatino layer is the selected layer
                if(`animLayer -query -selected $item` == 1){
                        //select all objects that are in the selected animation layer.
                    string $layers[] = {$item};
                    layerEditorSelectObjectAnimLayer($layers);
                    $nodesSelected = `ls -sl`;
                }
            }
        }
            
            //Set animation start to '0' and end time to an extreme '10000'
        playbackOptions -edit -min 0 -max 10000 -animationStartTime 0 -animationEndTime 10000;
            //Get last key frame
        int $lastKeyFrame = `findKeyframe -which last`;
            
            //Update the frame times only if the current animation layer has key frames in it
        if($lastKeyFrame > 1){
                //Update the startFrame integer field
            intField -edit -value 0 MP_AnimationStartFrameIF;
                //Update the endFrame integer field with retreived last key frame value
            intField -edit -value $lastKeyFrame MP_AnimationEndFrameIF;
                //Update the playback options
            playbackOptions -edit -min 0 -max $lastKeyFrame -animationStartTime 0 -animationEndTime $lastKeyFrame;
        }else{
                //Update the startFrame integer field with default
            intField -edit -value 0 MP_AnimationStartFrameIF;
                //Update the endFrame integer field with default
            intField -edit -value 48 MP_AnimationEndFrameIF;
                //Update the playback options
            playbackOptions -edit -min 0 -max 24 -animationStartTime 0 -animationEndTime 48;
        }
            
            //Check if we had previously selected nodes.
        if(size($currentSelection) != 0){
            select -clear;
            for($item in $currentSelection){
                    //Revert to previously selected nodes
                select -add $item;
            }
        }else{
                //Clear the selection
            select -clear;
        }
    }
}
///////////////////////////////////////////////////////////
// Process: MP_OutputPandaFileTypeUI                     //
// Updates the UI when a radio button is chosen          //
///////////////////////////////////////////////////////////
global proc MP_OutputPandaFileTypeUI()
{
    string $selectedRB = `radioCollection -query -select MP_OutputPandaFileTypeRC`;
    string $texPathOptions = `radioCollection -query -select MP_TexPathOptionsRC`;
    
    switch($selectedRB){
        case "MP_ChooseEggRB":
            print("Exporting only an Egg file\n");
                //Set options based on export file type
            switch($texPathOptions){
                case "MP_ChooseCustomRefPathRB":
                        //Enable egg file options
                    textField -edit -enable 1 MP_CustomEggTexPathTF;
                    button -edit -enable 1 MP_BrowseEggTexPathBTN;
                        //Disable bam file options
                    textField -edit -text "" -enable 0 MP_CustomBamTexPathTF;
                    button -edit -enable 0 MP_BrowseBamTexPathBTN;
                break;
                case "MP_ChooseCustomTexPathRB":
                        //Enable egg file options
                    textField -edit -enable 1 MP_CustomEggTexPathTF;
                    button -edit -enable 1 MP_BrowseEggTexPathBTN;
                        //Disable bam file options
                    textField -edit -text "" -enable 0 MP_CustomBamTexPathTF;
                    button -edit -enable 0 MP_BrowseBamTexPathBTN;
                break;
            }
        break;
        case "MP_ChooseEggBamRB":
            print("Exporting Egg and Bam files\n");
                //Set options based on export file type
            switch($texPathOptions){
                case "MP_ChooseCustomRefPathRB":
                        //Enable Bam features
                    textField -edit -enable 1 MP_CustomBamTexPathTF;
                    button -edit -enable 1 MP_BrowseBamTexPathBTN;
                        //Disable Egg features
                    textField -edit -text "" -enable 0 MP_CustomEggTexPathTF;
                    button -edit -enable 0 MP_BrowseEggTexPathBTN;
                break;
                case "MP_ChooseCustomTexPathRB":
                        //Enable Bam features
                    textField -edit -enable 1 MP_CustomBamTexPathTF;
                    button -edit -enable 1 MP_BrowseBamTexPathBTN;
                        //Enable Egg features
                    textField -edit -enable 1 MP_CustomEggTexPathTF;
                    button -edit -enable 1 MP_BrowseEggTexPathBTN;
                break;
            }
        break;
    }
}
///////////////////////////////////////////////////////////
// Process: MP_TexPathOptionsUI                          //
// Updates the UI when a radio button is chosen          //
///////////////////////////////////////////////////////////
global proc MP_TexPathOptionsUI()
{
    string $selectedRB = `radioCollection -query -select MP_TexPathOptionsRC`;
    string $outputPandaFileType = `radioCollection -query -select MP_OutputPandaFileTypeRC`;
    
    switch($selectedRB){
        case "MP_ChooseDefaultTexPathRB":
            print("Default Texture Path Chosen\n");
            textField -edit -text "" -enable 0 MP_CustomEggTexPathTF;
            button -edit -enable 0 MP_BrowseEggTexPathBTN;
            textField -edit -text "" -enable 0 MP_CustomBamTexPathTF;
            button -edit -enable 0 MP_BrowseBamTexPathBTN;
        break;
        case "MP_ChooseCustomRefPathRB":
            print("Custom Texture Reference Path Chosen\n");
                //Set options based on file type
            switch($outputPandaFileType){
                case "MP_ChooseEggRB":
                        //Disable bam file options
                    textField -edit -text "" -enable 0 MP_CustomBamTexPathTF;
                    button -edit -enable 0 MP_BrowseBamTexPathBTN;
                        //Enable egg file options
                    textField -edit -enable 1 MP_CustomEggTexPathTF;
                    button -edit -enable 1 MP_BrowseEggTexPathBTN;
                break;
                case "MP_ChooseEggBamRB":
                        //Enable bam file options
                    textField -edit -enable 1 MP_CustomBamTexPathTF;
                    button -edit -enable 1 MP_BrowseBamTexPathBTN;
                        //Disable egg file options
                    textField -edit -text "" -enable 0 MP_CustomEggTexPathTF;
                    button -edit -enable 0 MP_BrowseEggTexPathBTN;
                break;
            }
        break;
        case "MP_ChooseCustomTexPathRB":
            print("Custom Texture Path Chosen\n");
                //Set options based on file type
            switch($outputPandaFileType){
                case "MP_ChooseEggRB":
                        //Disable bam file options
                    textField -edit -text "" -enable 0 MP_CustomBamTexPathTF;
                    button -edit -enable 0 MP_BrowseBamTexPathBTN;
                        //Enable egg file options
                    textField -edit -enable 1 MP_CustomEggTexPathTF;
                    button -edit -enable 1 MP_BrowseEggTexPathBTN;
                break;
                case "MP_ChooseEggBamRB":
                        //Enable bam file options
                    textField -edit -enable 1 MP_CustomBamTexPathTF;
                    button -edit -enable 1 MP_BrowseBamTexPathBTN;
                        //Enable egg file options
                    textField -edit -enable 1 MP_CustomEggTexPathTF;
                    button -edit -enable 1 MP_BrowseEggTexPathBTN;
                break;
            }
        break;
    }
}
///////////////////////////////////////////////////////////
// Process: MP_OutputPathOptionsUI                       //
// Updates the UI when a radio button is chosen          //
///////////////////////////////////////////////////////////
global proc MP_OutputPathOptionsUI()
{
    string $selectedRB = `radioCollection -query -select MP_OutputPathOptionsRC`;
    
    switch($selectedRB){
        case "MP_ChooseDefaultOutputPathRB":
            print("Default Export File Path Chosen\n");
            textField -edit -text "" -enable 0 MP_CustomOutputPathTF;
            button -edit -enable 0 MP_BrowseOutputPathBTN;
        break;
        case "MP_ChooseCustomOutputPathRB":
            print("Custom Export File Path Chosen\n");
            textField -edit -enable 1 MP_CustomOutputPathTF;
            button -edit -enable 1 MP_BrowseOutputPathBTN;
        break;
    }
}
///////////////////////////////////////////////////////////
// Process: MP_OutputFilenameOptionsUI                   //
// Updates the UI when a radio button is chosen          //
///////////////////////////////////////////////////////////
global proc MP_OutputFilenameOptionsUI()
{
    string $selectedRB = `radioCollection -query -select MP_OutputFilenameOptionsRC`;
    
    switch($selectedRB){
        case "MP_ChooseOriginalFilenameRB":
            print("Default Export Filename Chosen\n");
            textField -edit -text "" -enable 0 MP_CustomFilenameTF;
            button -edit -enable 0 MP_BrowseFilenameBTN;
        break;
        case "MP_ChooseCustomFilenameRB":
            print("Custom Export Filename Chosen\n");
            textField -edit -enable 1 MP_CustomFilenameTF;
            button -edit -enable 1 MP_BrowseFilenameBTN;
        break;
    }
}
///////////////////////////////////////////////////////////
// Process: MP_TransformModeUI                           //
// Updates the UI when a radio button is chosen          //
///////////////////////////////////////////////////////////
global proc MP_TransformModeUI()
{
        /*  Notes:
            Specifies which transforms in the Maya file should be
            converted to transforms in the egg file.  The option may
            be one of all, model, dcs, or none.  The Panda default is
            model, which means only transforms on nodes that have the
            model or dcs flag are preserved in the converted egg file.
        */  
  
    string $selectedRB = `radioCollection -query -select MP_TransformModeRC`;
    switch($selectedRB){
        case "MP_ChooseTransformNoneRB":
            print("Saves no transform information\n");
        break;
        case "MP_ChooseTransformAllRB":
            print("Save transforms of all objects, PRESERVES local pivot, orientation, scale, and shear"
                  + "\nAll transform will remain when loaded into Panda3D\n");
        break;
        case "MP_ChooseTransformDCSRB":
            print("Save transforms of objects which have dcs-flag only,"
                  + "\nCLEARS local pivot, orientation, scale, and shear of the other objects."
                  + "\nAll transform will be frozen to the vertices and will be 0 when loaded into Panda3D\n");
        break;
        case "MP_ChooseTransformModelRB":
            print("Save transforms of objects which have model-flag or dcs-flag only,"
                  + "\nCLEARS local pivot, orientation, scale, and shear of the other objects"
                  + "\nAll transform will be frozen to the vertices and will be 0 when loaded into Panda3D\n");
        break;
    }
}
//////////////////////////////////////////////////////////
// Process: MP_Globals                                  //
// Contains MP_PandaVersion and egg-object-type arrays  //
//////////////////////////////////////////////////////////
global proc MP_Globals()
{
        //get the current Maya version
    string $mayaVersionLong = getApplicationVersionAsFloat();
    global string $gMP_MayaVersionShort;
    $gMP_MayaVersionShort = substituteAllString($mayaVersionLong, ".", "");
        
        //Strips the version zeroes if the version number length is less than 4
    if(`size($gMP_MayaVersionShort)`<4){
        $gMP_MayaVersionShort = substituteAllString($gMP_MayaVersionShort, "0", "");
    }

        //Global array containing all users versioned executable file names
    global string $gMP_PandaFileVersions[];
    
      /*
        Panda bam writing and reading version listing
            Panda version 	Writes 	Reads
            1.0.x 	      	 4.14 	4.0
            1.1.0 	      	 5.4 	5.0
            1.1.1 		     5.6 	5.0
            1.2.x 		     6.3 	6.0
            1.3.x 		     6.4 	6.0
            1.4.x 		     6.12 	6.0
            1.5.0 		     6.14 	6.0
            1.5.1         	 6.15 	6.0
            1.5.2         	 6.15 	6.0
            1.5.3         	 6.16 	6.0
            1.5.4         	 6.16 	6.0
            1.6.x 		     6.14 	6.14
            1.7.0 		     6.22 	6.14
            1.7.1         	 6.24 	6.14
            1.7.2         	 6.24 	6.14
            1.8.x 		     6.30 	6.14
            1.9.x 		     6.37 	6.14
            1.10.x 	  6.21 - 6.42 	6.14

            Note that Panda3D 1.10.x is able to write older .bam files.
            This can be done by putting this in Config.prc file: bam-version 6 21
      
        NOTICE REGARDING THE PANDA3D/BIN FILES:
            This notice is only pertinent if you have more than one version of Panda3D installed.
            You MUST ensure that the files being used are named differently between the different Panda3D installations.
            EXAMPLE: You have three Panda3D's of different versions installed,
                You MUST give all the egg2bam.exe, bam2egg.exe, pview.exe all different names.
                Otherwise, your computer will default to calling the file from your last installation.
                The most efficient renaming concept is to append the file names with their version at the end.
                EXAMPLE: For Panda3D-1.8.1, you might append the file [egg2bam.exe] into [egg2bam_630.exe].
                the addtional '630' or more technically '6.30', is the bam file version that is created using the
                egg2bam.exe file in version Panda3D-1.8.1.
                Add anything to them that will make them easily differenciated by yourself, and of course
                this script, even simply appending the panda version, i.e. 'egg2bam_181' is fine.
            
        INFORMATIONAL WARNING:
            One final issue that should be resolved if more than one Panda3D version is installed:
            The 'egg2maya[version].exe', 'maya2egg[version].exe', 'maya2egg[version]_bin',
            and the dll 'libp3mayaloader[version].dll' should only be present in the
            /panda3d[version]/bin/ folder for the installation that you have used the maya plugins for.
            Otherwise, your computer may throw a fit if there are more than one of these files visible
            to the computer when they are run. The best route to take is to put all those related files
            from the Panda3D installations you won't be using into a zip archive that is placed into
            the folder the files were originally located. Doing it this way, makes the files readily
            available if you need to restore them at some point in the future.
        
        To add an entry into the array:
        EACH ARRAY SET INCLUDES THE FOLLOWING FOUR ITEMS:
            First entry: The name you want displayed in the option menu.
            Second entry: bam2egg file name with no file extension.
            Third entry: egg2bam file name with no file extension.
            Fourth entry: pview file name with no file extension.
        
        Array Entry Example: To insert a bam version of 6.30(Panda3D-1.8.1),
            First, enter a comma at the end of the previous line of four items!
            Then, you would insert into the array the next line of four items:
                (notice file extensions are NOT used!)
                example: "6.30","egg2bam_630","bam2egg_630","pview_630"
      */  
        
        //NOTE: WHEN ENTERING IN OTHER VERSIONS, DO NOT INCLUDE THE FILE EXTENSIONS!!
        //Array Format: {"MenuDisplayText","bam2egg[version]","egg2bam[version]","pview[version]"}
        //Please leave the initial set of four entries as they are the fallback defaults used.
    $gMP_PandaFileVersions = { "Default","bam2egg","egg2bam","pview"
                             };
        
        //User editable egg-object-type global array.
        //NOTICE: Each egg-object-type that is added into the array MUST ALSO be referenced in a user Panda3D PRC file!!!
        //        This is necessary otherwise egg2bam will error if it cannot relate an egg-object-type.
        //The following is Panda3D's default egg-object-types
    global string $gMP_EggObjectTypeArray[];
    clear $gMP_EggObjectTypeArray;
    $gMP_EggObjectTypeArray = {"barrier","floor","shadow-cast","dupefloor","smooth-floors","sphere","tube",
                                "trigger","trigger-sphere","invsphere","bubble","polylight",
                                "portal","dual","ghost","glass","glow",
                                "binary","indexed","model","dcs","notouch",
                                "billboard","double-sided","seq2","seq4","seq6",
                                "seq8","seq10","seq12","seq24"
                              };
    
        //Global variable that keeps track of whether or not user has seen the import Panda file notification.
        //It is designed so that the user only sees the notification once during session.
    global int $gMP_ChoosePandaFileNotice = 0;
}
///////////////////////////////////////////////////////////
// Process: MP_CreatePandaExporterWindow                 //
// Creates the GUI control                               //
///////////////////////////////////////////////////////////
global proc MP_CreatePandaExporterWindow()
{
        //Process Variables
    global string $gMP_PandaFileVersions[];
    global string $gMP_MayaVersionShort;
    global string $gMP_ReleaseRevision;
    
        //Exporter GUI Creation
    window -retain -title ("Panda Exporter " + $gMP_ReleaseRevision + " - Modded by 'Sweet'") -width 400 -height 400 -sizeable 1 -visible 0 MP_PandaExporter;
        rowLayout -numberOfColumns 2 -rowAttach 1 "top" 0 -rowAttach 2 "top" 0 -rowAttach 3 "top" 0;
                //Construct LEFT Column
            columnLayout -columnAttach "left" 0 -rowSpacing 0;
                frameLayout -label "Export File Type" -height 65 -width 200;
                    columnLayout -columnAttach "left" 0 -rowSpacing 0;
                        radioCollection MP_ExportOptionsRC;
                        rowLayout -numberOfColumns 3;
                            radioButton -collection MP_ExportOptionsRC
                                            -label "Actor"
                                            -onCommand ("MP_ExportOptionsUI")
                                            MP_ChooseActorRB;
                            radioButton -collection MP_ExportOptionsRC
                                            -label "Animation"
                                            -onCommand ("MP_ExportOptionsUI")
                                            MP_ChooseAnimationRB;
                            radioButton -collection MP_ExportOptionsRC
                                            -label "Both"
                                            -onCommand ("MP_ExportOptionsUI")
                                            MP_ChooseBothRB;
                        setParent -upLevel;
                        rowLayout -numberOfColumns 2;
                            radioButton -collection MP_ExportOptionsRC
                                            -label "Mesh"
                                            -onCommand ("MP_ExportOptionsUI")
                                            -select MP_ChooseMeshRB;
                            radioButton -collection MP_ExportOptionsRC
                                            -label "Pose"
                                            -onCommand ("MP_ExportOptionsUI")
                                            MP_ChoosePoseRB;
                        setParent -upLevel;
                    setParent -upLevel;
                setParent -upLevel;
                frameLayout -label "Transforms To Save:" -height 65 -width 200;
                    columnLayout -columnAttach "left" 0 -rowSpacing 0;
                        radioCollection MP_TransformModeRC;
                        rowLayout -numberOfColumns 3;
                            radioButton -collection MP_TransformModeRC
                                            -label "None"
                                            -onCommand ("MP_TransformModeUI")
                                            MP_ChooseTransformNoneRB;
                            separator -width 28 -style "none";
                            radioButton -collection MP_TransformModeRC
                                            -label "All"
                                            -onCommand ("MP_TransformModeUI")
                                            MP_ChooseTransformAllRB;
                        setParent -upLevel;
                        rowLayout -numberOfColumns 3;
                            radioButton -collection MP_TransformModeRC
                                            -label "DCS Flag"
                                            -onCommand ("MP_TransformModeUI")
                                            MP_ChooseTransformDCSRB;
                            separator -width 10 -style "none";
                            radioButton -collection MP_TransformModeRC
                                            -label "Model/DCS flag"
                                            -select
                                            -onCommand ("MP_TransformModeUI")
                                            MP_ChooseTransformModelRB;
                        setParent -upLevel;
                    setParent -upLevel;
                setParent -upLevel;
                frameLayout -label "Export Options" -height 215 -width 200;
                    columnLayout -columnAttach "left" 0;
                        checkBox -label "Export only selected objects " -value 0
                                    -annotation ("Will export only the selected scene nodes")
                                    MP_ExportSelectedCB;
                        checkBox -label "Double sided faces" -value 0
                                    -annotation ("If this flag is not specified,the default is to"
                                                   + "\ntreat all polygons as single-sided,unless an"
                                                   + "\negg object type of \"double-sided\" is set.")
                                    MP_ExportBfaceCB;
                        checkBox -label "Overwrite existing files" -value 1
                                    -annotation ("Will overwrite file if it already exists")
                                    MP_ExportOverwriteCB;
                        checkBox -label "Run PView after export" -value 0
                                    -annotation ("When exporting, it runs the final file, e.g. egg or bam, against pview command")
                                    MP_ExportPviewCB;
                        checkBox -label "Only legacy shaders" -value 0
                                    -annotation ("Use this flag to turn off modern (Phong) shader generation"
                                                    + "\nand treat shaders as if they were Lamberts (legacy)")
                                    MP_ExportLegacyShadersCB;
                        checkBox -label "Keep all UV's" -value 1
                                    -annotation ("Convert all UV sets on all vertices, even those that do"
                                                    + "\nnot appear to be referenced by any textures.")
                                    MP_ExportKeepUvsCB;
                        checkBox -label "Round UV's" -value 1
                                    -annotation ("Round up uv coordinates to the nearest 1/100th. i.e."
                                                    + "\n-0.001 becomes0.0; 0.444 becomes 0.44; 0.778 becomes 0.78")
                                    MP_ExportRoundUvsCB;
                        checkBox -label "Tangents+Binormals for all UV sets" -value 1
                                    -annotation ("Compute tangent and binormal for all texture coordinate sets"
                                                    + "\nThis is equivalent to -tbn \"*\"")
                                    MP_ExportTbnallCB;
                        checkBox -label "Convert Lights" -enable 1 -value 0
                                    -changeCommand "MP_LightsSelectedUI"
                                    -annotation ("Convert all light nodes to locators. Will preserve position and rotation")
                                    MP_ExportLightsCB;
                        checkBox -label "Convert Cameras" -enable 1 -value 0
                                    -changeCommand "MP_CamerasSelectedUI"
                                    -annotation ("Convert all camera nodes to locators. Will preserve position and rotation")
                                    MP_ExportCamerasCB;
                        checkBox -label "Remove groundPlane_transform" -enable 1 -value 1
                                    -changeCommand "MP_RemoveGroundPlaneUI"
                                    -annotation ("Removes the \"groundPlane_transform\" node from the exported egg file(s)."
                                                    + "\nCurrently, only Mesh exporting supports the removal of the tuple!"
                                                    + "\nThough this is not normally utilized, care must be taken that the node"
                                                    + "\nis in fact EMPTY, before engaging this to be removed!"
                                                    + "\nThe primary purpose of adding this, was to offer a method of removing"
                                                    + "\nthe empty node from the egg file, as it is exported, via maya2egg.")
                                    MP_RemoveGroundPlaneCB;
                    setParent -upLevel;
                setParent -upLevel;
                frameLayout -label "Bam Specific Options" -height 85 -width 200;
                    columnLayout -columnAttach "left" 0;
                        rowLayout -numberOfColumns 3;
                            optionMenu -width 100
                                        -annotation ("Bam file version to use for creating the bam file"
                                                        + "These can be added to the $gMP_PandaFileVersions Array as needed")
                                        MP_BamVersionOptionMenu;
                                    //Construct the Bam Version Option Menu
                                for($i=0;$i<size($gMP_PandaFileVersions);$i++)
                                {
                                        //Generate menu item
                                    menuItem -label $gMP_PandaFileVersions[$i];
                                        //Increase counter by number of units between each version entry
                                    $i=$i+3;
                                }
                            separator -width 5 -style "none";
                            text "Bam Version";
                        setParent -upLevel;
                        rowLayout -numberOfColumns 2;
                            checkBox -label "Pack Textures into Bam (-rawtex)"
                                        -value 0
                                        MP_RawtexCB;
                        setParent -upLevel;
                        rowLayout -numberOfColumns 2;
                            checkBox -label "Flatten (-flatten 1)"
                                        -value 0
                                        MP_FlattenCB;
                        setParent -upLevel;
                    setParent -upLevel;
                setParent -upLevel;
                frameLayout -label "Convert Units From" -height 50 -width 200;
                    columnLayout -columnAttach "left" 0;
                        optionMenu MP_UnitMenu;
                                menuItem -collection MP_UnitMenu -label "mm";
                                menuItem -collection MP_UnitMenu -label "cm";
                                menuItem -collection MP_UnitMenu -label "m";
                                menuItem -collection MP_UnitMenu -label "km";
                                menuItem -collection MP_UnitMenu -label "in";
                                menuItem -collection MP_UnitMenu -label "ft";
                                menuItem -collection MP_UnitMenu -label "yd";
                                menuItem -collection MP_UnitMenu -label "nmi";
                                menuItem -collection MP_UnitMenu -label "mi";
                                optionMenu -edit -value "cm" MP_UnitMenu;
                    setParent -upLevel;
                setParent -upLevel;
                frameLayout -label "Output File Type:" -height 70 -width 200;
                    columnLayout -columnAttach "left" 0;
                        radioCollection MP_OutputPandaFileTypeRC;
                        radioButton -collection MP_OutputPandaFileTypeRC
                                    -label "EGG (ASCII) Only"
                                    -select
                                    -onCommand ("MP_OutputPandaFileTypeUI")
                                    MP_ChooseEggRB;
                        radioButton -collection MP_OutputPandaFileTypeRC
                                    -label "EGG(ASCII)   and   BAM(Binary)"
                                    -onCommand ("MP_OutputPandaFileTypeUI")
                                    MP_ChooseEggBamRB;
                    setParent -upLevel;
                setParent -upLevel;
                frameLayout -label "Egg-Object-Types:" -height 50 -width 200;
                    columnLayout -columnAttach "left" 0;
                        rowLayout -numberOfColumns 2;
                            button -label "Add Egg Tags"
                                    -width 90 -height 20
                                    -command ("MP_AddEggObjectTypesGUI")
                                    -annotation ("Displays the Egg-Object-Type window in which"
                                                  + "\nthe user selects tags to add to selected nodes."
                                                )
                                    MP_AddEggTypeBTN;
                            button -label "Delete Egg Tags"
                                    -width 90 -height 20
                                    -command ("MP_GetEggObjectTypes")
                                    -annotation ("Displays an Egg-Object-Type window in which"
                                                  + "\nthe user can select tags to delete from selected nodes."
                                                )
                                    MP_DeleteEggTypeBTN;
                        setParent -upLevel;
                    setParent -upLevel;
                setParent -upLevel;
            setParent -upLevel;

                //Construct RIGHT Column
            columnLayout -columnAttach "left" 0 -rowSpacing 0;
                frameLayout -label "Output Path & Name Options:" -height 320 -width 270;
                    columnLayout -columnAttach "left" 0;
                        text -label "Texture Path Options:" -fn "boldLabelFont";
                            radioCollection MP_TexPathOptionsRC;
                        radioButton -select
                                    -collection MP_TexPathOptionsRC
                                    -label "Reference textures relative to maya file (default)"
                                    -annotation "Reference textures relative to maya file (default)"
                                    -onCommand ("MP_TexPathOptionsUI")
                                    MP_ChooseDefaultTexPathRB;
                        radioButton -collection MP_TexPathOptionsRC
                                    -label "Reference textures relative to specified path"
                                    -annotation ("References textures to relative to selected specified path"
                                                    + "\nNOTE: If exporting a bam and egg,"
                                                    + "\nThe egg file textures get referenced to the Maya file."
                                                    + "\nThe bam file textures will be referenced to specified directory."
                                                )
                                    -onCommand ("MP_TexPathOptionsUI")
                                    MP_ChooseCustomRefPathRB;
                        radioButton -collection MP_TexPathOptionsRC
                                    -label "Copy textures and make relative to specified path"
                                    -annotation ("Copies textures to, and makes, textures relative to selected specified path"
                                                    + "\nNOTE: If exporting a bam and egg, textures get copied-to \"Egg file texture Ref Directory\""
                                                    + "\nThe bam file ref directory defaults to this directory, but can be modified further."
                                                    + "\nIf it is modified, the edited path MUST start with the copied-to directory path."
                                                )
                                    -onCommand ("MP_TexPathOptionsUI")
                                    MP_ChooseCustomTexPathRB;
                        text -label "Egg File Texture Ref Path:";
                        rowLayout -numberOfColumns 3 -rowAttach 1 "top" 0;
                            textField -width 215 -enable 0 
                                    -annotation ("Egg File custom texture reference path"
                                                    + "\n"
                                                    + "\nNOTE: If using the copy-to for the textures,"
                                                    + "\nthis will be the copied-to directory."
                                                    + "\nIf exporting both an egg and a bam file,"
                                                    + "\nthe texture referencing for the bam file may be"
                                                    + "\nfurther modified below."
                                                )
                                    MP_CustomEggTexPathTF;
                            button -label "Browse"
                                    -enable 0 
                                    -annotation ("Browse for Egg File custom texture reference path"
                                                    + "\n"
                                                    + "\nNOTE: If using the copy-to for the textures,"
                                                    + "\nthis will be the copied-to directory."
                                                    + "\nIf exporting both an egg and a bam file,"
                                                    + "\nthe texture referencing for the bam file may be"
                                                    + "\nfurther modified below."
                                                )
                                    -command ("MP_BrowseForFolderPreProcess\"customRelativeEggTexturePath\"")
                                    MP_BrowseEggTexPathBTN;
                        setParent -u;
                        text -label "Bam File Texture Ref Path:";
                        rowLayout -numberOfColumns 3 -rowAttach 1 "top" 0;
                            textField -width 215 -enable 0
                                    -annotation ("Bam File custom texture reference path"
                                                    + "\n"
                                                    + "\nNOTE:"
                                                    + "\nIf just referencing textures and exporting both an Egg and Bam file,"
                                                    + "\nThe Egg file is referenced to Maya file."
                                                    + "\nThe Bam file will be referenced to specified path."
                                                    + "\nThe Bam file reference path MUST start with the path to where textures are located."
                                                    + "\n"
                                                    + "\nIf copying textures, this path MUST start with the copied-to directory path"
                                                    + "\ndefined in the \"Egg file texture Ref Directory\" above"
                                                )
                                    MP_CustomBamTexPathTF;
                            button -label "Browse"
                                    -enable 0
                                    -annotation ("Browse for Bam File custom texture reference path"
                                                    + "\n"
                                                    + "\nNOTE:"
                                                    + "\nIf just referencing textures and exporting both an Egg and Bam file,"
                                                    + "\nThe Egg file is referenced to Maya file."
                                                    + "\nThe Bam file will be referenced to specified path."
                                                    + "\nThe Bam file reference path MUST start with the path to where textures are located."
                                                    + "\n"
                                                    + "\nIf copying textures, this path MUST start with the copied-to directory path"
                                                    + "\ndefined in the \"Egg file texture Ref Directory\" above"
                                                )
                                    -command ("MP_BrowseForFolderPreProcess\"customRelativeBamTexturePath\"")
                                    MP_BrowseBamTexPathBTN;
                        setParent -u;
                        separator -height 5 -style "none";
                        text -label "Output File Path:" -fn "boldLabelFont";
                            radioCollection MP_OutputPathOptionsRC;
                        radioButton -select
                                    -collection MP_OutputPathOptionsRC
                                    -label "Export to root directory of source file (default)"
                                    -onCommand ("MP_OutputPathOptionsUI")
                                    MP_ChooseDefaultOutputPathRB;
                        radioButton -collection MP_OutputPathOptionsRC
                                    -label "Export to other directory:"
                                    -onCommand ("MP_OutputPathOptionsUI")
                                    MP_ChooseCustomOutputPathRB;
                        rowLayout -numberOfColumns 2 -rowAttach 1 "top" 0;
                            textField -width 215 -enable 0 MP_CustomOutputPathTF;
                            button -label "Browse"
                                    -enable 0
                                    -command ("MP_BrowseForFolderPreProcess\"customOutputPath\"")
                                    MP_BrowseOutputPathBTN;
                        setParent -u;
                        separator -height 5 -style "none";
                        text -label "Output File Name:" -fn "boldLabelFont";
                            radioCollection MP_OutputFilenameOptionsRC;
                        rowLayout -numberOfColumns 2;
                            radioButton -select
                                        -collection MP_OutputFilenameOptionsRC
                                        -label "Original filename"
                                        -onCommand ("MP_OutputFilenameOptionsUI")
                                        MP_ChooseOriginalFilenameRB;
                            radioButton -collection MP_OutputFilenameOptionsRC
                                        -label "Alternate filename"
                                        -onCommand ("MP_OutputFilenameOptionsUI")
                                        MP_ChooseCustomFilenameRB;
                        setParent -upLevel;
                        rowLayout -nc 3 -rowAttach 1 "top" 0;
                            textField -text ""
                                        -enable 0
                                        -width 215
                                        -annotation ("Browse to select or enter custom output file name.")
                                        MP_CustomFilenameTF;
                            button -label "Browse"
                                    -enable 0
                                    -command ("MP_BrowseForFilePreProcess\"customFilename\"")
                                    -annotation ("Browse to select or enter custom output file name.")
                                    MP_BrowseFilenameBTN;
                        setParent -u;
                    setParent -upLevel;
                setParent -upLevel;
                frameLayout -label "Animation Options" -height 120 -width 270;
                    columnLayout -columnAttach "left" 0;
                        rowLayout -numberOfColumns 2;
                            text -label "Character Name"
                                    -enable 0
                                    -annotation ("Character name associated with Model/Animation set"
                                                    + "\nAny spaces will be replaced with an underscore!")
                                    MP_CharacterNameLabel;
                            textField -text ""
                                        -enable 0
                                        -width 170
                                        -annotation ("Character name associated with Model/Animation set"
                                                    + "\nAny spaces will be replaced with an underscore!")
                                        MP_CharacterNameTF;
                        setParent -upLevel;
                        rowLayout -numberOfColumns 2;
                            text -label "Force Joint"
                                    -enable 0
                                    -annotation "Separate multiple node names with a space"
                                    MP_ForceJointLabel;
                            textField -text ""
                                        -enable 0
                                        -width 170
                                        -annotation "Separate multiple node names with a space"
                                        MP_ForceJointTF;
                        setParent -upLevel;
                        radioCollection MP_AnimationOptionsRC;
                        rowLayout -numberOfColumns 2;
                            radioButton -select
                                        -collection MP_AnimationOptionsRC
                                        -label "Full Frames    "
                                        -enable 0
                                        -onCommand("MP_AnimationOptionsUI(\"animationMode\",\"\")")
                                        MP_chooseFullAnimationRangeRB;
                            radioButton -collection MP_AnimationOptionsRC
                                        -label "Custom Frames"
                                        -enable 0
                                        -onCommand("MP_AnimationOptionsUI(\"animationMode\",\"\")")
                                        MP_chooseCustomAnimationRangeRB;
                        setParent -upLevel;
                        rowLayout -numberOfColumns 6;
                            text -label "Start Frame" -enable 0
                                    -annotation ("Set the animation start frame: Default is 0"
                                                    + "\nRange is 0 to 10,000")
                                    MP_AnimationStartFrameLabel;
                            intField -width 40 -height 20 -noBackground false -enable 0
                                    -min 0 -max 10000 -value 0 -step 1
                                    -annotation ("Set the animation start frame: Default is 0"
                                                    + "\nRange is 0 to 10,000")
                                    -changeCommand("MP_AnimationOptionsUI(\"updateFrameValues\",\"startFrameIFChanged\")")
                                    MP_AnimationStartFrameIF;
                            intScrollBar -width 33 -height 18 -horizontal true -enable 0
                                    -min 0 -max 10000 -value 0 -step 1
                                    -annotation ("Set the animation start frame: Default is 0"
                                                    + "\nRange is 0 to 10,000")
                                    -changeCommand("MP_AnimationOptionsUI(\"updateFrameValues\",\"startFrameSliderMoved\")")
                                    -dragCommand ("MP_AnimationOptionsUI(\"updateFrameValues\",\"startFrameSliderMoved\")")
                                    MP_AnimationStartFrameSlider;
                            text -label "End Frame" -enable 0
                                    -annotation ("Set the animation end frame: Default is 48"
                                                    + "\nRange is 0 to 10,000")
                                    MP_AnimationEndFrameLabel;
                            intField -width 40 -height 20 -noBackground false -enable 0
                                    -min 0 -max 10000 -value 48 -step 1
                                    -annotation ("Set the animation end frame: Default is 48"
                                                    + "\nRange is 0 to 10,000")
                                    -changeCommand("MP_AnimationOptionsUI(\"updateFrameValues\",\"endFrameIFChanged\")")
                                    MP_AnimationEndFrameIF;
                            intScrollBar -width 33 -height 18 -horizontal true -enable 0
                                    -min 0 -max 10000 -value 48 -step 1
                                    -annotation ("Set the animation end frame: Default is 48"
                                                    + "\nRange is 0 to 10,000")
                                    -changeCommand("MP_AnimationOptionsUI(\"updateFrameValues\",\"endFrameSliderMoved\")")
                                    -dragCommand ("MP_AnimationOptionsUI(\"updateFrameValues\",\"endFrameSliderMoved\")")
                                    MP_AnimationEndFrameSlider;;
                        setParent -upLevel;
                    setParent -upLevel;
                setParent -upLevel;
                frameLayout -label "Export Scene or Export Nodes:" -height 80 -width 270;
                    columnLayout -columnAttach "left" 0;
                        rowLayout -numberOfColumns 2;
                            button -label "Export Current Scene"
                                    -width 110 -height 20
                                    -command "MP_StartSceneExport"
                                    -annotation ("Creates a Panda Egg, (and a Bam file if both are chosen),"
                                                  + "\nby first exporting the scene as a Maya file."
                                                  + "\nIt then runs maya2egg[version] on the maya file,"
                                                  + "\nwhile using the selected export options."
                                                  + "\n\nIf both egg and bam were chosen to export,"
                                                  + "\nit will run the selected version of egg2bam on the egg file,"
                                                  + "\nwhile using the selected [Bam Specific Options].")
                                    MP_ExportSceneBTN;
                            button -label "Sent To Pview"
                                    -width 80 -height 20
                                    -command ("MP_Send2Pview\"\"")
                                    -annotation ("Sends either the selected nodes, Or, the entire scene if nothing is selected"
                                                + "\nTo the libmayapview plugin if it is installed and loaded"
                                                + "\nIf plugin is not loaded or installed, it prompts for file to view instead")
                                    MP_Send2PviewBTN;
                        setParent -upLevel;
                        rowLayout -numberOfColumns 3;
                            button -label "Convert Nodes To Panda"
                                    -width 135 -height 20
                                    -command "MP_ExportNodesToPandaFiles"
                                    -annotation ("Converts selected node, or nodes, to Panda files."
                                                + "\nSupports multiple selections"
                                                + "\nExports each selected node as its own set of files."
                                                + "\nFile name will be node names, unless a custom name is chosen"
                                                + "\nDefault will export a Maya binary file and an egg file."
                                                + "\nHowever, if the '[EGG(ASCII) and BAM(Binary)]' option is selected"
                                                + "\nit will produce a set of three files for each node selected."
                                                + "\na maya .mb file, a Panda .bam and an .egg file, all in the chosen output directory.")
                                    MP_ConvertNodesToPandaBTN;
                        setParent -upLevel;
                    setParent -upLevel;
                setParent -upLevel;
                frameLayout -label "Convert Files:" -height 80 -width 270;
                    columnLayout -columnAttach "left" 0;
                        rowLayout -numberOfColumns 3;
                            button -label "Maya File 2 Egg"
                                    -width 85 -height 20
                                    -command "MP_GetMayaFile2Egg"
                                    -annotation ("Creates a Panda Egg file by running"
                                                    + "\nmaya2egg[version] on the selected Maya file(s)")
                                    MP_GetMayaFile2EggBTN;
                            button -label "Egg File 2 Bam"
                                    -width 80 -height 20
                                    -command "MP_GetEggFile2Bam"
                                    -annotation ("Creates a Panda Bam file by running the selected version"
                                                  + "\nof egg2bam and the currently chosen export options"
                                                  + "\non the selected egg file(s).")
                                    MP_GetEggFile2BamBTN;
                            button -label "Bam File 2 Egg"
                                    -width 80 -height 20
                                    -command "MP_GetBamFile2Egg"
                                    -annotation ("Runs bam2egg on the selected bam file(s)")
                                    MP_GetBamFile2EggBTN;
                        setParent -upLevel;
                        rowLayout -numberOfColumns 3;
                            button -label "Import Panda File"
                                    -width 100 -height 20
                                    -command "MP_ImportPandaFile"
                                    -annotation ("Imports selected Panda Bam or Egg file(s).")
                                    MP_ImportPandaFileBTN;
                        setParent -upLevel;
                    setParent -upLevel;
                setParent -upLevel;
            setParent -upLevel;
        setParent -top;
}

global string $gMainWindow;
setParent $gMainWindow;

    //Delete any current instances of the menu
if(`menu -exists MP_PandaMenu`){
    deleteUI -menu MP_PandaMenu;
}
    //Delete any current instances of the exportedPandaFile window
if (`window -exists MP_NodesExportedToPandaFilesGUI`){
    deleteUI -window MP_NodesExportedToPandaFilesGUI;
}
    //Delete any current instances of the MP_PandaExporter window
if(`window -exists MP_PandaExporter`){
    deleteUI -window MP_PandaExporter;
}
    //Delete any current instances of the MP_AddEggObjectTypesWindow window
if (`window -exists MP_AddEggObjectTypesWindow`){
    deleteUI -window MP_AddEggObjectTypesWindow;
}
    //Delete any current instances of the MP_DeleteEggObjectTypesWindow window
if (`window -exists MP_DeleteEggObjectTypesWindow`){
    deleteUI -window MP_DeleteEggObjectTypesWindow;
}
    
    //Define main menu and menu items
menu -label "Panda3D" MP_PandaMenu;
    //Set the MP_PandaMenu as the parent for the following menuItems
setParent -menu MP_PandaMenu;
    menuItem -label "Panda Export GUI..." -command "MP_PandaExporterUI";
    menuItem -label "View file in PView..." -command "MP_GetFile2Pview";
    menuItem -label "Add Egg-Type Attribute" -command "MP_AddEggObjectTypesGUI";
    menuItem -label "Panda3D Home" -command "MP_GotoPanda3D";
    menuItem -label "Panda3D Manual" -command "MP_GotoPanda3DManual";
    menuItem -label "Panda3D Help Forums" -command "MP_GotoPanda3DForum";
    menuItem -label "Download Panda3D-SDK" -command "MP_GotoPanda3DSDKDownload";
    
    //The following processes define the functions called by using the menu items
global proc MP_GotoPanda3D()
{
    showHelp -absolute "http://www.panda3d.org";
}
global proc MP_GotoPanda3DManual()
{
    showHelp -absolute "http://www.panda3d.org/manual/index.php/Main_Page";
}
global proc MP_GotoPanda3DForum ()
{
    showHelp -absolute "https://www.panda3d.org/forums/index.php";
}
global proc MP_GotoPanda3DSDKDownload()
{
    showHelp -absolute "http://www.panda3d.org/download.php?sdk";
}
    //Displays the exporter GUI if it has already been created
    //  Otherwise, it creates the GUI window, then displays it
global proc MP_PandaExporterUI()
{
    if(`window -exists MP_PandaExporter`==0){
        MP_CreatePandaExporterWindow();
        showWindow MP_PandaExporter;
    }else{
        showWindow MP_PandaExporter;
    }
}

    //Call Globals
MP_Globals();

    //Variable to hold our release revision
global string $gMP_ReleaseRevision;
$gMP_ReleaseRevision = "v1.9";

    //Call the GUI creation process
MP_CreatePandaExporterWindow();
